% Erlang-side API (minimal wrapper made available to the user code) in order to
% interact with the foobar service through its driver.
%
% Relies on the service_support common facility that factors out the relevant
% cross-service, generic features.
%
% Refer to inc/foobar.h for the vanilla, C foobar API.
%
-module(foobar).


% For the foo record:
-include("foobar.hrl").


% Detailed comment for foo_status/0.
-type foo_status() :: 'low_speed' | 'moderate_speed' | 'full_speed'.


% Detailed comment for tur_status/0.
-type tur_status() :: 'tur_value' | 'non_tur_value'.


-export_type([ foo/0, foo_status/0, tur_status/0 ]).



% API declaration.


% Detailed comment for foo/1.
-spec foo( integer() ) -> integer().


% Detailed comment for bar/2.
-spec bar( float(), atom() ) -> foo().


% Detailed comment for baz/2.
-spec baz( integer(), text_utils:ustring() ) -> tur_status().


% Detailed comment for tur/0.
-spec tur() -> bool().


% Detailed comment for frob/1.
-spec frob( tur_status() ) -> text_utils:ustring().



% Everything below should be generated by seaplus_parse_transform.erl:



% To auto-define base, generic functions transverse to all services, notably:
%
% - start/0, start_link/0
% - stop/0
% - list_exported_service_functions/0
%
-include("seaplus.hrl").


% The name of the driver executable:
%
% (no need to specify it here, as it derives naturally here from the name of the
% tested service)
%
%-define( driver_exec_name, "foobar_service_driver" ).


% Service generic API.


-export([ start/0, start_link/0, restart/0, stop/0,
		  get_service_key_name() ]).


% Starts the support of this foobar service.
%
-spec start() -> void()
start() ->
	seaplus:start( ?MODULE ).


% Starts and links the support of this foobar service.
%
-spec start_link() -> void()
start_link() ->
	seaplus:start_link( ?MODULE ).


% Restarts the supportof this foobar service (ex: to overcome a detected crash
% thereof).
%
-spec restart() -> void().
restart() ->
	seaplus:restart( ?MODULE ).


% Stops the support of this foobar service.
%
-spec stop() -> void()
stop() ->
	seaplus:stop( ?MODULE ).



% Service utilities:


% Better than ?MODULE:
-define( foobar_port_dict_key, seaplus_foobar_port_dict_key ).


% Returns the key under which this service shall be referenced in the process
% dictionary of the (creator) user process.
%
-spec get_service_key() -> seaplus:service_key().
get_service_key() ->
	?seaplus_foobar_port_dict_key.



% Service-specific API, delegated through the driver.
%
% A call is either to return a result (if any) or to throw an exception in case
% of failure (rather than sending back for example either { ok, Result } or {
% error, Reason }.

% The service key is directly inlined (no need to use get_service_key/0 here).

% Function identifiers are directly specified as immediate values in the
% function definitions (ex: 1) rather than as defines (ex: ?foo_id) which are
% preprocessor elements and thus would not be in the AST anyway.
%
% The name of functions is not necessary (their identifier will suffice) hence
% not transmitted.


-export([ foo/1, bar/2, baz/2, tur/0, frob/1 ]).


foo( A ) ->
	seaplus:call_port_for( ?foobar_port_dict_key, 1, [ A ] ).


bar( A, B ) ->
	seaplus:call_port_for( ?foobar_port_dict_key, 2, [ A, B ] ).


baz( A, B ) ->
	seaplus:call_port_for( ?foobar_port_dict_key, 3, [ A, B ] ).


tur() ->
	seaplus:call_port_for( ?foobar_port_dict_key, 4, [] ).


frob( A ) ->
	seaplus:call_port_for( ?foobar_port_dict_key, 5, [ A ] ).
