<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Welcome to the Ceylan-Seaplus documentation</title>
<meta content="Seaplus, C, C++, integration, interface, bridge, Erlang" name="keywords" />
<link rel="stylesheet" href="pygments-default.css" type="text/css" />
<link rel="stylesheet" href="seaplus.css" type="text/css" />
<link href="seaplus-icon.png" rel="icon">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="document" id="seaplus-streamlining-a-safe-execution-of-c-c-code-from-erlang">
<h1 class="title">Seaplus: Streamlining a safe execution of C/C++ code from Erlang</h1>

<span class="target" id="top"></span><p><span class="raw-html"><a name="seaplus_top"></a></span></p>
<p><span class="raw-html"><div class="banner"><p><em>Seaplus documentation</em> <a href="http://seaplus.esperide.org">browse latest</a> <a href="https://olivier-boudeville.github.io/Ceylan-Seaplus/seaplus.html">browse mirror</a> <a href="seaplus.pdf">get PDF</a> <a href="#seaplus_top">go to top</a> <a href="#seaplus_toc">go to toc</a> <a href="#seaplus_bottom">go to bottom</a> <a href="api-doc/index.html">browse API</a> <a href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus">go to project</a> <a href="mailto:about(dash)seaplus(at)esperide(dot)com?subject=[Ceylan-Seaplus]%20Remark">email us</a></p></div></span></p>
<p><span class="raw-html"><center><img src="seaplus-title.png" id="responsive-image-small"></img></span>
</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body"><p class="first">Copyright (C) 2018-2023 Olivier Boudeville</p>
</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><p class="first">about (dash) seaplus (at) esperide (dot) com</p>
</td>
</tr>
<tr class="field"><th class="field-name">Creation date:</th><td class="field-body"><p class="first">Sunday, December 23, 2018</p>
</td>
</tr>
<tr class="field"><th class="field-name">Lastly updated:</th><td class="field-body"><p class="first">Sunday, March 19, 2023</p>
</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body"><p class="first">1.1.8</p>
</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body"><p class="first">Stable</p>
</td>
</tr>
<tr class="field"><th class="field-name">Dedication:</th><td class="field-body"><p class="first">Users and maintainers of the <tt class="docutils literal">Seaplus</tt> bridge.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body"><p class="first">The role of the <a class="reference external" href="http://seaplus.esperide.org/">Seaplus</a> bridge  (part of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan">Ceylan</a> project) is to control C or C++ code from Erlang, not as NIF but thanks to a port, and to streamline the corresponding integration process.</p>
<p class="last">We present here a short overview of these services, to introduce them to newcomers.
The next level of information is either to browse the <a class="reference external" href="api-doc/index.html">Seaplus API documentation</a> or simply to read the corresponding <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus">source files</a>, which are intensely commented and generally straightforward.</p>
</td>
</tr>
</tbody>
</table>
<p><span class="raw-html"></center></span></p>
<p>The latest version of this documentation is to be found at the <a class="reference external" href="http://seaplus.esperide.org">official Seaplus website</a> (<tt class="docutils literal"><span class="pre">http://seaplus.esperide.org</span></tt>).</p>
<p><span class="raw-html">This Seaplus documentation is also available in the PDF format (see <a href="seaplus.pdf">seaplus.pdf</a>), and mirrored <a href="http://olivier-boudeville.github.io/Ceylan-Seaplus/seaplus.html">here</a>.</span></p>
<p></p>
<p></p>
<p><span class="raw-html"><a name="seaplus_toc"></a></span></p>
<div class="contents topic" id="topic-1">
<span id="table-of-contents"></span><p class="topic-title"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="toc-entry-1">Overview</a></li>
<li><a class="reference internal" href="#usage" id="toc-entry-2">Usage</a></li>
<li><a class="reference internal" href="#wrapping-up" id="toc-entry-3">Wrapping Up</a></li>
<li><a class="reference internal" href="#licence" id="toc-entry-4">Licence</a></li>
<li><a class="reference internal" href="#current-stable-version-download-build" id="toc-entry-5">Current Stable Version, Download &amp; Build</a><ul>
<li><a class="reference internal" href="#using-cutting-edge-git" id="toc-entry-6">Using Cutting-Edge GIT</a></li>
<li><a class="reference internal" href="#using-rebar3" id="toc-entry-7">Using Rebar3</a></li>
<li><a class="reference internal" href="#testing-seaplus" id="toc-entry-8">Testing Seaplus</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-technical-points" id="toc-entry-9">Miscellaneous Technical Points</a><ul>
<li><a class="reference internal" href="#seaplus-log-system" id="toc-entry-10">Seaplus Log System</a></li>
<li><a class="reference internal" href="#customising-function-bindings-on-the-erlang-side" id="toc-entry-11">Customising Function Bindings on the Erlang Side</a></li>
<li><a class="reference internal" href="#debugging-a-seaplus-based-driver" id="toc-entry-12">Debugging a Seaplus-based Driver</a></li>
<li><a class="reference internal" href="#testing-seaplus-1" id="toc-entry-13">Testing Seaplus</a></li>
<li><a class="reference internal" href="#towards-a-more-general-c-c-interface" id="toc-entry-14">Towards a more General C/C++ Interface</a></li>
<li><a class="reference internal" href="#c-c-code-formatting" id="toc-entry-15">C/C++ Code Formatting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#issues-planned-enhancements" id="toc-entry-16">Issues &amp; Planned Enhancements</a></li>
<li><a class="reference internal" href="#support" id="toc-entry-17">Support</a></li>
<li><a class="reference internal" href="#seaplus-inner-workings" id="toc-entry-18">Seaplus Inner Workings</a></li>
<li><a class="reference internal" href="#please-react" id="toc-entry-19">Please React!</a></li>
<li><a class="reference internal" href="#ending-word" id="toc-entry-20">Ending Word</a></li>
</ul>
</div>
<p></p>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#toc-entry-1">Overview</a></h1>
<p>A typical use-case is <strong>having a C or C++ library of interest that we would like be able to use from Erlang</strong>, whereas, for any reason (availability of sources, complexity, size, performance or interest), recoding it (in Erlang) is not desirable.</p>
<p>However tempting it may be to integrate tightly C/C++ code to the Erlang VM (typically through a <a class="reference external" href="http://erlang.org/doc/tutorial/nif.html">NIF</a>), one may prefer trading maximum performances for safety, and run that C/C++ code (which is often at last partly foreign, hence possibly unreliable) into a separate, isolated (operating system) process.</p>
<p>Then the integrated code will not be able to crash the Erlang application, and for example any memory leak it would induce would only affect its own OS process (that, moreover, depending on the use case, may be safely restarted) - not the application one.</p>
<p>Indeed, taking into account the Erlang <a class="reference external" href="http://erlang.org/doc/tutorial/users_guide.html">Interoperability Tutorial</a>, the following approaches are the most commonly considered ones when having to make C/C++ code available from Erlang:</p>
<ul class="simple">
<li>raw <strong>ports</strong> and <strong>linked-in drivers</strong>: they are mostly obsolete for the task at hand (superseded by better counterparts)</li>
<li><tt class="docutils literal">os:cmd/1</tt>: a rudimentary solution that offers little control and requires much syntactic parsing effort</li>
<li>custom <strong>socket-based protocol</strong>: quite low-level and complicated</li>
<li><tt class="docutils literal">NIF</tt>: as mentioned, they may jeopardise the VM (depending on the use case, this may be acceptable or not)</li>
<li><a class="reference external" href="http://erlang.org/doc/tutorial/cnode.html">C-Node</a> and, now, <a class="reference external" href="http://erlang.org/doc/man/ei.html">ei</a> (previously <a class="reference external" href="http://erlang.org/doc/tutorial/erl_interface.html">Erl_Interface</a>): this is the combination that we preferred for Seaplus, and that we tried to streamline/automate here, at least partially</li>
</ul>
<p>In a nutshell, this approach consists on spawning a &quot;fake&quot; Erlang node written in C (the <tt class="docutils literal"><span class="pre">C-Node</span></tt>) and using the standard <em>Erlang external term format</em> in order to communicate with it (relying for that on the <tt class="docutils literal">ei</tt> facilities). Doing so allows a seamless communication to happen, in spite of language heterogeneity.</p>
<p>C-Node and Erl_Interface/ei help a lot, yet, as shown in <a class="reference external" href="http://erlang.org/doc/tutorial/erl_interface.html#erlang-program">this reference example</a>, quite a lot of boiler-plate/bridging code (home-made encoding and conventions) remains needed.</p>
<p>The <strong>goal of Seaplus is to reduce that interfacing effort</strong>, thanks to a set of generic, transverse functions on either side (modules in Erlang, a library in C/C++) and the use of metaprogramming (i.e. the Seaplus parse transform) in order to generate at least a part of the code needed in both sides, while leaving to the developer enough leeway so that he can define precisely the mapping interface that he prefers (e.g. with regards to naming, types introduced and used, management of resource ownership, etc.).</p>
<p>As a result, the result of a Seaplus integration can be seen as an easily obtained ei-based C-Node on a bit of steroids.</p>
<p><tt class="docutils literal"><span class="pre">Ceylan-Seaplus</span></tt> relies on various facilities offered by the <a class="reference external" href="http://myriad.esperide.org">Ceylan-Myriad</a> toolbox.</p>
<p>The project repository is located <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus">here</a>.</p>
</div>
<div class="section" id="usage">
<h1><a class="toc-backref" href="#toc-entry-2">Usage</a></h1>
<p>So we would have here a (possibly third-party) service (typically a library, directly usable from C, offering a set of functions) that we want to integrate, i.e. to make available from Erlang.</p>
<p>Let's suppose that said service is named <tt class="docutils literal">Foobar</tt>, and that the functions it provides (hence on the C side) are declared as (typically in some <tt class="docutils literal">foobar.h</tt> header file <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>, referring to a possibly opaque <tt class="docutils literal">foobar.so</tt> library - i.e. whose sources may remain unknown):</p>
<pre class="code c literal-block">
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="w">
</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo_data</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w">

</span><span class="k">enum</span><span class="w"> </span><span class="n">foo_status</span><span class="w"> </span><span class="p">{</span><span class="n">low_speed</span><span class="p">,</span><span class="n">moderate_speed</span><span class="p">,</span><span class="n">full_speed</span><span class="p">};</span><span class="w">
</span><span class="k">enum</span><span class="w"> </span><span class="n">tur_status</span><span class="w"> </span><span class="p">{</span><span class="n">tur_value</span><span class="p">,</span><span class="n">non_tur_value</span><span class="p">};</span><span class="w">

</span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo_data</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">foo_status</span><span class="w"> </span><span class="n">status</span><span class="p">);</span><span class="w">
</span><span class="k">enum</span><span class="w"> </span><span class="n">tur_status</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w">
</span><span class="kt">bool</span><span class="w"> </span><span class="nf">tur</span><span class="p">();</span><span class="w">
</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">frob</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="n">tur_status</span><span class="p">);</span>
</pre>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>See the full, unedited version of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar/inc/foobar.h">foobar.h</a> test header that is actually used.</td></tr>
</tbody>
</table>
<p>With the definition of this example, we ensured to reproduce real-life situations, like atoms vs enums, dynamic memory allocation (for the returned struct) and runtime failures (since calling <tt class="docutils literal">foo(0)</tt> is to trigger a division by zero).</p>
<p>What would be the corresponding ideal Erlang interface to make such a fantastic Foobar service available?</p>
<p>First of all, multiple corresponding Erlang APIs can be considered, and some design choices have to be made (we can foresee that some are more elegant/convenient than others, and that a perfect, universal, one-size-fit-all automated mapping does not seem so achievable).</p>
<p>An easy step is to decide, at least in most cases, to map each of these C functions to an Erlang counterpart function that, unsurprisingly, bears the same name and most of the time has the same arity, and to have them gathered into a single module that would be best named <tt class="docutils literal">foobar</tt> (and thus shall be defined in <tt class="docutils literal">foobar.erl</tt>).</p>
<p>We believe that, in order to rely on a convenient Erlang-side API for this service, adaptations have to be made (e.g. with regard to typing), and thus that it should preferably be defined in an ad-hoc manner (i.e. it should be tailor-made, rather than be automatically generated through a mapping possibly suffering from impedance mismatch).</p>
<p>So such a service-specific API shall be devised by the service integrator (i.e. the developer in charge of the integration of the C/C++ code to Erlang). But how?</p>
<p>At the very least, what will be offered on the Erlang side by our <tt class="docutils literal">foobar</tt> module shall be somehow specified. A very appropriate way of doing so is to list (only) the <a class="reference external" href="http://erlang.org/doc/reference_manual/typespec.html">type specifications</a> of the targeted counterpart functions meant to be ultimately available (defined and exported) from Erlang, like in <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">foobar</span><span class="p">).</span><span class="w">

</span><span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;seaplus.hrl&quot;</span><span class="p">).</span><span class="w">

</span><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">foo_data</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">count</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">float</span><span class="p">()}).</span><span class="w">
</span><span class="p">-</span><span class="ni">type</span><span class="w"> </span><span class="n">foo_data</span><span class="p">()</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nl">#foo_data</span><span class="p">{}.</span><span class="w">

</span><span class="p">-</span><span class="ni">type</span><span class="w"> </span><span class="n">foo_status</span><span class="p">()</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">'low_speed'</span><span class="p">|</span><span class="n">'moderate_speed'</span><span class="p">|</span><span class="n">'full_speed'</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="ni">type</span><span class="w"> </span><span class="n">tur_status</span><span class="p">()</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">'tur_value'</span><span class="p">|</span><span class="n">'non_tur_value'</span><span class="p">.</span><span class="w">

</span><span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">integer</span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">().</span><span class="w">
</span><span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="nb">float</span><span class="p">(),</span><span class="w"> </span><span class="n">foo_status</span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">foo_data</span><span class="p">().</span><span class="w">
</span><span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">baz</span><span class="p">(</span><span class="n">integer</span><span class="p">(),</span><span class="w"> </span><span class="nn">text_utils</span><span class="p">:</span><span class="nf">ustring</span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tur_status</span><span class="p">().</span><span class="w">
</span><span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">tur</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">boolean</span><span class="p">().</span><span class="w">
</span><span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">frob</span><span class="p">(</span><span class="n">tur_status</span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nn">text_utils</span><span class="p">:</span><span class="nf">ustring</span><span class="p">().</span>
</pre>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>See the full, unedited version of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar.erl">foobar.erl</a> API module that is actually used, together with its <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar.hrl">foobar.hrl</a> header file.</td></tr>
</tbody>
</table>
<p>The Seaplus header include allows notably to mark this <tt class="docutils literal">foobar</tt> module as a service stub (so that the build system can determine this module is to be fleshed out).</p>
<p>It can be included in a more OTP-compliant fashion with:</p>
<pre class="literal-block">
-include_lib(&quot;seaplus/include/seaplus.hrl&quot;).
</pre>
<p>Comments (description, usage, examples) are also expected to be joined to these specs, they are omitted in this documentation only for brevity.</p>
<p><strong>Facility functions</strong> that all integrated services will need, and whose signature (if not implementation) would be the same from a service to another (e.g. to start/stop this service from Erlang), will also certainly be needed.</p>
<p>However, listing these facility functions in our <tt class="docutils literal">foobar</tt> module would offer little interest, should they involve no service-specific part; so these extra functions are to remain implicit here <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a>.</p>
<p>These service-level built-in functions automatically defined by Seaplus of user interest are, notably:</p>
<ul class="simple">
<li><tt class="docutils literal">start/0</tt>: starts said service, a <tt class="docutils literal">{driver_crashed,ErrorReason}</tt> exception being thrown should the driver or the integrated library crash (e.g. SEGV)</li>
<li><tt class="docutils literal">start_link/0</tt>: starts and links said service to the user process, expected to receive an EXIT signal (and thus, unless trapping them, crashing in turn) should the driver or the integrated library crash</li>
<li><tt class="docutils literal">restart/0</tt>: restarts the service, typically after it was started with <tt class="docutils literal">start/0</tt>, failed and threw an exception (that was caught by the user code)</li>
<li><tt class="docutils literal">stop/0</tt>: stops the service</li>
</ul>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td><p class="first">Note though that, at least for some services, specific initialisation/tear-down functions may exist in the vanilla, C version of that service. In that case, they should be triggered by the Seaplus-exposed <tt class="docutils literal">start</tt>/<tt class="docutils literal">stop</tt> service primitives.</p>
<p>So, for each facility function <tt class="docutils literal">start/0</tt>, <tt class="docutils literal">start_link/0</tt> and <tt class="docutils literal">stop/0</tt>, the Seaplus parse transform determines whether it is already defined in the service at hand (i.e., for example, whether the user defined specifically a <tt class="docutils literal">foobar:start/0</tt> function). If yes, then Seaplus enriches automatically that code with the one needed for its own initialisation (Seaplus'one taking place <em>before</em> the service's initialisation). If no, then Seaplus defines a brand new <tt class="docutils literal">start/0</tt> that is limited to its own needs.</p>
<p class="last">As a result, from the point of view of the service user, in all cases the service can be started or stopped with a single call (possibly taking care under the hood of both Seaplus and the service itself).</p>
</td></tr>
</tbody>
</table>
<p>Of course such a module, as it was defined above (i.e. just as a set of function specifications, with no implementation thereof), is useless and would not even compile as such. But the Seaplus parse transform will automatically enrich and transform it so that, once the C part (the driver) is available, the <tt class="docutils literal">Foobar</tt> service becomes fully usable from Erlang, with no extra boilerplate code to be added by the Erlang integrator.</p>
<p>More precisely, for each of the function type specifications defined by the user in that module, a corresponding bridging implementation will be generated on the Erlang side and added (unless the <tt class="docutils literal">foobar</tt> module already includes one, so that the user can selectively override the Seaplus code generation), whilst all the needed facility functions will be included as well.</p>
<p>Here is a corresponding (mostly meaningless) usage example <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a> of this <tt class="docutils literal">foobar</tt> module, when executed from any given process (e.g. a test one):</p>
<pre class="code erlang literal-block">
<span class="nn">foobar</span><span class="p">:</span><span class="nf">start</span><span class="p">(),</span><span class="w">
</span><span class="nv">MyFooData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">foobar</span><span class="p">:</span><span class="nf">bar</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">,</span><span class="n">full_speed</span><span class="p">),</span><span class="w">
</span><span class="nv">NewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">foobar</span><span class="p">:</span><span class="nf">foo</span><span class="p">(</span><span class="nv">MyFooData</span><span class="nl">#foo_data.count</span><span class="p">),</span><span class="w">
</span><span class="nv">Res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="nn">foobar</span><span class="p">:</span><span class="nf">tur</span><span class="p">()</span><span class="w"> </span><span class="k">of</span><span class="w">
  </span><span class="n">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nn">foobar</span><span class="p">:</span><span class="nf">baz</span><span class="p">(</span><span class="nv">NewCount</span><span class="p">,</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w">
  </span><span class="n">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="n">non_tur_value</span><span class="w">
</span><span class="k">end</span><span class="p">,</span><span class="w">
</span><span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;Having: </span><span class="si">~s~n</span><span class="s">&quot;</span><span class="p">,[</span><span class="nn">foobar</span><span class="p">:</span><span class="nf">frob</span><span class="p">(</span><span class="nv">Res</span><span class="p">)]),</span><span class="w">
</span><span class="nn">foobar</span><span class="p">:</span><span class="nf">stop</span><span class="p">().</span>
</pre>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>See the full, unedited, richer version of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar_test.erl">foobar_test.erl</a> module used to test the Erlang-integrated service (emulating an actual use of that service).</td></tr>
</tbody>
</table>
<p>At this point, one may think that, thanks to these function specs, the full counterpart C bridging code might have been automagically generated as well, in the same movement as the Erlang bridging code? Unfortunately, not exactly! At least, not yet; maybe some day (if ever possible and tractable). Currently: only <em>parts</em> of it are generated.</p>
<p>C-side elements will have been produced indeed by the Seaplus parse-transform (notably the function mapping include, used to map functions on either sides, and also, if not already existing, a compilable template of the C driver), but the conversion (thanks to <a class="reference external" href="http://erlang.org/doc/man/ei.html">ei</a> now) from the Erlang terms received by the port into arguments that will feed the C functions and on the other way round (i.e. from the C results to the Erlang terms that shall be sent back) is still left to the service integrator.</p>
<p>This work remains, yet it is also a chance to better adapt the bridging code to the interfacing contract one would like to be fulfilled, for example with regard to resource ownership. Indeed, should the C part take pointers as arguments, shall it delete them once having used them? Conversely, should a C function return a pointer to a dynamically allocated memory, who is responsible for the eventual deallocation of it? How the C implementation can maintain a state of its own between calls?</p>
<p>To address these questions, service-specific choices and conventions have to be applied, and this information cannot be generically found or deduced by an algorithm (including of course the Seaplus one) from the C/C++ pre-existing code. As a result, we believe that in all cases some effort remains to be done by the service integrator.</p>
<p>So: we saw that thanks to Seaplus nothing special had to be done on the Erlang side (the <tt class="docutils literal">foobar.erl</tt> stub will suffice; refer to the <a class="reference internal" href="#customising-function-bindings-on-the-erlang-side">Customising Function Bindings on the Erlang Side</a> section in order to address more specific/advanced needs), and that the C side deserved some love to be complete; what kind of extra work is needed then?</p>
<p>Seaplus generated an header file, <tt class="docutils literal">foobar_seaplus_api_mapping.h</tt> (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/doc/foobar_seaplus_api_mapping.h">here</a> for a small, unedited <em>example</em> of it), in charge of telling that C side about the actual encoding of the service functions across the bridge. In our example this generated header would contain:</p>
<pre class="code c literal-block">
<span class="cp">#define FOO_1_ID  1
#define BAR_2_ID  2
#define BAZ_2_ID  3
#define TUR_0_ID  4
#define FROB_1_ID 5</span>
</pre>
<p>This indicates that for example the <tt class="docutils literal">baz/2</tt> Erlang function, as hinted by its type specification in <tt class="docutils literal">foobar.erl</tt>, has been associated by Seaplus to the <tt class="docutils literal">BAZ_2_ID</tt> (namely, of course: <tt class="docutils literal"><span class="pre">${FUNCTION_NAME}_${ARITY}_ID</span></tt>) identifier (whose value happens to be <tt class="docutils literal">3</tt> here <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a>).</p>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td>Of course no code should rely on that actual value, which could change from a generation to another, or as the API is updated; only the (stable by design) <tt class="docutils literal">BAZ_2_ID</tt> identifier shall be trusted by user code.</td></tr>
</tbody>
</table>
<p>The C part of the bridge (i.e., the service driver), typically defined in <tt class="docutils literal">foobar_seaplus_driver.c</tt>, is thus to include that <tt class="docutils literal">foobar_seaplus_api_mapping.h</tt> generated header in order to map the Erlang function identifier in a call request to its processing.</p>
<p>Should no such driver implementation already exist, Seaplus will generate a template version of it (a template that can nevertheless be successfully compiled and linked), which will include everything needed but the (service-specific) C logic that shall be added by the service integrator in order to:</p>
<ol class="arabic simple">
<li>convert the received arguments (Erlang terms) into their C counterparts (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/include/seaplus_getters.h">seaplus_getters.h</a> for that, typically the <tt class="docutils literal">read_*_parameter</tt> functions)</li>
<li>call the corresponding C integrated function</li>
<li>convert its result the other way round, so that a relevant Erlang term is returned (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/include/seaplus_setters.h">seaplus_setters.h</a> for that, typically the <tt class="docutils literal">write_*_result</tt> functions)</li>
</ol>
<p>See the full, unedited version of the generated <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/doc/foobar_seaplus_driver.c">foobar_seaplus_driver.c template</a>  corresponding to the Foobar service (one may note the placeholders in each <tt class="docutils literal">case</tt> branch of the function identifier switch).</p>
<p>Seaplus offers moreover various helpers to facilitate the writing of this C driver (i.e. the filling of said generated template); they are gathered in the Seaplus library (typically <tt class="docutils literal">libseaplus.so</tt>) and available by including the Seaplus C header file, <tt class="docutils literal">seaplus.h</tt> (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/include/seaplus.h">here</a>).</p>
<p>Based on these elements, the actual bridging code can be written, like in the following shortened version. The <tt class="docutils literal">FOO_1_ID</tt> case is among the simplest possible call, while the <tt class="docutils literal">BAR_2_ID</tt> one is more complex; for both calls no memory leak is involved (see the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar_seaplus_driver.c">full source</a> of this test driver, notably for the conversion helpers used for <tt class="docutils literal">bar/2</tt>):</p>
<pre class="code c literal-block">
<span class="p">[...]</span><span class="w">
</span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w">
</span><span class="p">{</span><span class="w">

  </span><span class="n">byte</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current_read_buf</span><span class="p">;</span><span class="w">

  </span><span class="n">input_buffer</span><span class="w"> </span><span class="n">read_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current_read_buf</span><span class="p">;</span><span class="w">

  </span><span class="c1">// Provided by the Seaplus library:
</span><span class="w">  </span><span class="n">start_seaplus_driver</span><span class="p">(</span><span class="n">read_buf</span><span class="p">);</span><span class="w">

  </span><span class="c1">// For the mandatory result:
</span><span class="w">  </span><span class="n">output_buffer</span><span class="w"> </span><span class="n">output_sm_buf</span><span class="p">;</span><span class="w">

  </span><span class="cm">/* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */</span><span class="w">
  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">read_command</span><span class="p">(</span><span class="n">read_buf</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
  </span><span class="p">{</span><span class="w">

    </span><span class="c1">// Current index in the input buffer (for decoding purpose):
</span><span class="w">    </span><span class="n">buffer_index</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">

    </span><span class="cm">/* Will be set to the corresponding Seaplus-defined function identifier (e.g.
     * whose value is FOO_1_ID):
     *
     */</span><span class="w">
    </span><span class="n">fun_id</span><span class="w"> </span><span class="n">current_fun_id</span><span class="p">;</span><span class="w">

    </span><span class="cm">/* Will be set to the number of parameters obtained from Erlang for the
     * function whose identifier has been transmitted:
     *
     */</span><span class="w">
    </span><span class="n">arity</span><span class="w"> </span><span class="n">param_count</span><span class="p">;</span><span class="w">

    </span><span class="n">read_function_information</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current_fun_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param_count</span><span class="p">);</span><span class="w">

    </span><span class="n">prepare_for_command</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output_sm_buf</span><span class="p">);</span><span class="w">


    </span><span class="c1">// Now, taking care of the corresponding function call:
</span><span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">current_fun_id</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="w">

      </span><span class="k">case</span><span class="w"> </span><span class="no">FOO_1_ID</span><span class="p">:</span><span class="w">
        </span><span class="c1">// -spec foo(integer()) -&gt; integer() vs int foo(int a)
</span><span class="w">        </span><span class="n">check_arity_is</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">param_count</span><span class="p">,</span><span class="w"> </span><span class="n">FOO_1_ID</span><span class="p">);</span><span class="w">

        </span><span class="cm">/*
         * So we expect the (single, hence first) parameter to
         * be an integer:
         */</span><span class="w">
        </span><span class="kt">long</span><span class="w"> </span><span class="n">foo_a_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_int_parameter</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Actual call:
</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">foo_a_param</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Sending of the result:
</span><span class="w">        </span><span class="n">write_int_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output_sm_buf</span><span class="p">,</span><span class="w"> </span><span class="n">foo_result</span><span class="p">);</span><span class="w">

        </span><span class="k">break</span><span class="p">;</span><span class="w">

      </span><span class="k">case</span><span class="w"> </span><span class="no">BAR_2_ID</span><span class="p">:</span><span class="w">

        </span><span class="cm">/* -spec bar(float(), foo_status()) -&gt; foo_data() vs
         * struct foo * bar(double a, enum foo_status status)
         */</span><span class="w">
        </span><span class="n">check_arity_is</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">param_count</span><span class="p">,</span><span class="w"> </span><span class="n">BAR_2_ID</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Getting first the Erlang float:
</span><span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">bar_double_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_double_parameter</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Then the atom for foo_status():
</span><span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">atom_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_atom_parameter</span><span class="p">(</span><span class="n">read_buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Converting said atom for the C API:
</span><span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="n">foo_status</span><span class="w"> </span><span class="n">bar_status_param</span><span class="w"> </span><span class="o">=</span><span class="w">
            </span><span class="n">get_foo_status_from_atom</span><span class="p">(</span><span class="n">atom_name</span><span class="p">);</span><span class="w">

        </span><span class="n">free</span><span class="p">(</span><span class="w"> </span><span class="n">atom_name</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">

        </span><span class="c1">// Actual call (ownership of struct_res transferred to this caller):
</span><span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo_data</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">struct_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">bar_double_param</span><span class="p">,</span><span class="w">
                                           </span><span class="n">bar_status_param</span><span class="p">);</span><span class="w">

        </span><span class="c1">// Defining a separated writing function is more convenient here:
</span><span class="w">        </span><span class="n">write_foo_data_record_from_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output_sm_buf</span><span class="p">,</span><span class="w"> </span><span class="n">struct_res</span><span class="p">);</span><span class="w">

        </span><span class="n">free</span><span class="p">(</span><span class="n">struct_res</span><span class="p">);</span><span class="w">

        </span><span class="k">break</span><span class="p">;</span><span class="w">

    </span><span class="p">[...]</span><span class="w">

    </span><span class="k">default</span><span class="o">:</span><span class="w">
        </span><span class="n">raise_error</span><span class="p">(</span><span class="s">&quot;Unknown function identifier: %u&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current_fun_id</span><span class="p">);</span><span class="w">

    </span><span class="p">}</span><span class="w">

    </span><span class="n">finalize_command_after_writing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output_sm_buf</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">

  </span><span class="p">}</span><span class="w">

  </span><span class="c1">// output_sm_buf internally already freed appropriately.
</span><span class="w">
  </span><span class="n">stop_seaplus_driver</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span><span class="w">

</span><span class="p">}</span>
</pre>
<p>One may finally compare the aforementioned <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/doc/foobar_seaplus_driver.c">generated template</a> with - once it has been appropriately filled by the service integrator - the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar_seaplus_driver.c">final version</a> of this driver.</p>
<p>This version of course compiles, links and allows to run the <tt class="docutils literal">foobar_test</tt> successfully (once Seaplus is built, one may run, from the <tt class="docutils literal"><span class="pre">test/c-test</span></tt> directory, <tt class="docutils literal">make test</tt> for that).</p>
<p>If wanting to see, beyond this test, what could be an actual, more involved driver (larger, richer, partly interrupt-based), one may refer to the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Mobile/blob/master/src/mobile_seaplus_driver.c">Ceylan-Mobile driver</a>.</p>
</div>
<div class="section" id="wrapping-up">
<h1><a class="toc-backref" href="#toc-entry-3">Wrapping Up</a></h1>
<p>We believe that, in order to make a pre-existing C/C++ library available to Erlang while not going the NIF route (typically when not wanting to jeopardise the Erlang VM for that), Seaplus offers a good option in terms of safety, low overhead and simplicity.</p>
<p>The overall integration process is quite streamlined, and we tried to reduce as much as possible the size and complexity of the service-specific integration code that remains needed.</p>
<p>For example one may contrast the few Foobar-specific files (<a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar.hrl">foobar.hrl</a>, <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar.erl">foobar.erl</a> and the final <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/test/c-test/foobar_seaplus_driver.c">foobar_seaplus_driver.c</a> - i.e. the ones that shall be written or filled by the service integrator), with:</p>
<ul class="simple">
<li>the generated ones, namely the header file for function identifier mapping (<a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/doc/foobar_seaplus_api_mapping.h">foobar_seaplus_api_mapping.h</a>) and the original driver template (<a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/doc/foobar_seaplus_driver.c">foobar_seaplus_driver.c</a>)</li>
<li>the ones implementing the Seaplus generic support, namely <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/include/seaplus.hrl">seaplus.hrl</a>, <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/src/seaplus.erl">seaplus.erl</a>, <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/include/seaplus.h">seaplus.h</a>, <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/src/seaplus.c">seaplus.c</a> and <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/src/seaplus_parse_transform.erl">seaplus_parse_transform.erl</a></li>
</ul>
<p>As mentioned, beside the Seaplus-included <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/tree/master/test/c-test">Foobar example</a>, one may refer to the <a class="reference external" href="http://mobile.esperide.org">Ceylan-Mobile</a> project for a complete, standalone use of Seaplus.</p>
<p></p>
</div>
<div class="section" id="licence">
<span id="free-software"></span><h1><a class="toc-backref" href="#toc-entry-4">Licence</a></h1>
<p>Seaplus is licensed by its author (Olivier Boudeville) under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the former <a class="reference external" href="http://www.erlang.org/EPLICENSE">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
<li><a class="reference external" href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License</a> (GPL), version 3.0 or later</li>
<li><a class="reference external" href="http://www.gnu.org/licenses/lgpl.html">GNU Lesser General Public License</a> (LGPL), version 3.0 or later</li>
</ul>
<p>This allows the use of the Seaplus code in as wide a variety of software projects as possible, while still maintaining copyleft on this code.</p>
<p>Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of licence terms he/she is operating under.</p>
<p>We hope that enhancements will be back-contributed (e.g. thanks to merge requests), so that everyone will be able to benefit from them.</p>
<p></p>
</div>
<div class="section" id="current-stable-version-download-build">
<h1><a class="toc-backref" href="#toc-entry-5">Current Stable Version, Download &amp; Build</a></h1>
<p>This integration layer, <tt class="docutils literal"><span class="pre">Ceylan-Seaplus</span></tt>, relies (only) on:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.erlang.org/">Erlang</a></li>
<li>a suitable C/C++ compiler, typically <a class="reference external" href="https://gcc.gnu.org">gcc</a></li>
<li>the <a class="reference external" href="http://myriad.esperide.org">Ceylan-Myriad</a> base layer</li>
</ul>
<p>We prefer using GNU/Linux, sticking to the latest stable release of Erlang, and building it from sources, thanks to GNU <tt class="docutils literal">make</tt>.</p>
<p>Refer to the corresponding <a class="reference external" href="http://myriad.esperide.org#prerequisites">Myriad prerequisite section</a>  for more precise guidelines, knowing that Ceylan-Seaplus does not need modules with conditional support such as <tt class="docutils literal">crypto</tt> or <tt class="docutils literal">wx</tt>.</p>
<div class="section" id="using-cutting-edge-git">
<h2><a class="toc-backref" href="#toc-entry-6">Using Cutting-Edge GIT</a></h2>
<p>We try to ensure that the main line (in the <tt class="docutils literal">master</tt> branch) always stays functional. Evolutions are to take place in feature branches.</p>
<p>Once proper Erlang and C environments are available, the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad">Ceylan-Myriad repository</a> should be cloned and built, before doing the same with the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus">Ceylan-Seaplus repository</a>, like in:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Olivier-Boudeville/Ceylan-Myriad<span class="w"> </span>myriad<span class="w">
</span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>myriad<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make<span class="w"> </span>all<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..<span class="w">
</span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Olivier-Boudeville/Ceylan-Seaplus<span class="w"> </span>seaplus<span class="w">
</span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>seaplus<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make<span class="w"> </span>all
</pre>
<p>(for OTP compliance, using short names, such as <tt class="docutils literal">myriad</tt> or <tt class="docutils literal">seaplus</tt>, for clones rather than long ones, such as <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt> or <tt class="docutils literal"><span class="pre">Ceylan-Seaplus</span></tt>, is recommended)</p>
<p>One can then test the whole with:</p>
<pre class="code bash literal-block">
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>test/c-test<span class="w">
</span>$<span class="w"> </span>make<span class="w"> </span><span class="nb">test</span>
</pre>
</div>
<div class="section" id="using-rebar3">
<h2><a class="toc-backref" href="#toc-entry-7">Using Rebar3</a></h2>
<p>Most of the usual rebar3 machinery is in place and functional, at the price of some workarounds that are transparent for the users.</p>
<p>So the only Seaplus prerequisite (<a class="reference external" href="https://myriad.esperide.org">Myriad</a>) and Seaplus itself can be obtained simply thanks to:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Olivier-Boudeville/Ceylan-Seaplus.git<span class="w"> </span>seaplus<span class="w">
</span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>seaplus<span class="w">
</span>$<span class="w"> </span>rebar3<span class="w"> </span>compile
</pre>
<p>Then Seaplus and its tests shall be ready for a successful execution.</p>
<p>Note that rebar3 is an alternate way of building Seaplus, as one may rely directly on our make-based system instead.</p>
</div>
<div class="section" id="testing-seaplus">
<h2><a class="toc-backref" href="#toc-entry-8">Testing Seaplus</a></h2>
<p>Once <a class="reference external" href="https://myriad.esperide.org">Myriad</a> and Seaplus itself have been built (for that refer to either <a class="reference internal" href="#using-cutting-edge-git">Using Cutting-Edge GIT</a> or <a class="reference internal" href="#using-rebar3">Using Rebar3</a>), just run from the root directory of Seaplus:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>make<span class="w"> </span><span class="nb">test</span>
</pre>
<p>The testing shall complete successfully (if it is not the case, see our <a class="reference internal" href="#support">support</a> section).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Seaplus is built and tested at each commit through <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/actions?query=workflow%3A%22Erlang+CI%22">continuous integration</a>, and the same holds for its only prerequisite (<a class="reference external" href="https://myriad.esperide.org">Myriad</a>).
Reciprocally this procedure applies to the projects based on it, such as <a class="reference external" href="https://mobile.esperide.org/">Ceylan-Mobile</a>, so in terms of usability, confidence should be rather high.</p>
</div>
</div>
</div>
<div class="section" id="miscellaneous-technical-points">
<h1><a class="toc-backref" href="#toc-entry-9">Miscellaneous Technical Points</a></h1>
<div class="section" id="seaplus-log-system">
<h2><a class="toc-backref" href="#toc-entry-10">Seaplus Log System</a></h2>
<p>When integrating a C service, the most difficult part is ensuring the sanity of the C driver, i.e. knowing what happens within it whenever converting terms back and forth, handling pointers, allocating memory, crashing unexpectedly, etc. (a.k.a. the joys of C programming).</p>
<p>To facilitate troubleshooting, Seaplus provides a log system, allowing to trace the various operations done <em>by the driver</em> (including the user code and the Seaplus facilities on which it relies).</p>
<p>This log system is enabled by default. To disable it (then no runtime penalty will be incurred), set <tt class="docutils literal">SEAPLUS_ENABLE_LOG</tt> to <tt class="docutils literal">0</tt> (e.g. add the <tt class="docutils literal"><span class="pre">-DSEAPLUS_ENABLE_LOG=0</span></tt> option when compiling the library, see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/GNUmakevars.inc">GNUmakevars.inc</a> for the various build settings).</p>
<p>So running a Seaplus-integrated service, with log system enabled, should produce a <tt class="docutils literal"><span class="pre">seaplus-driver.N.log</span></tt> timestamped text log file, where <tt class="docutils literal">N</tt> is the (operating system level) PID <a class="footnote-reference" href="#footnote-6" id="footnote-reference-6">[6]</a> of the process corresponding to the driver.</p>
<p>Example content:</p>
<pre class="literal-block">
[2019/3/6 14:32:42][debug] Starting Seaplus session...
[2019/3/6 14:32:42][debug] Starting the Seaplus C driver, with a buffer of 32768 bytes.
[2019/3/6 14:32:42][trace] Driver started.
[2019/3/6 14:32:42][debug] Read 2 bytes.
[2019/3/6 14:32:42][debug] Will read 37 bytes.
[2019/3/6 14:32:42][debug] Read 37 bytes.
[2019/3/6 14:32:42][trace] New command received.
[2019/3/6 14:32:42][debug] Read integer 2.
[2019/3/6 14:32:42][debug] Reading command: function identifier is 2.
[2019/3/6 14:32:42][debug] 2 parameter(s) received for this function.
[2019/3/6 14:32:42][debug] Executing bar/2.
[2019/3/6 14:32:42][debug] Read double 2.000000e+00.
[2019/3/6 14:32:42][debug] Read head as atom 'moderate_speed'.
[2019/3/6 14:32:42][debug] Will write 47 bytes.
</pre>
<table class="docutils footnote" frame="void" id="footnote-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-6">[6]</a></td><td>Including the PID in the filename allows notably, in case of driver restart, to ensure that the logs of the new instance do not overwrite the ones of the restarted one.</td></tr>
</tbody>
</table>
<p>The end of these logs is automatically located, fetched and displayed in the applicative traces by Seaplus in case of a driver crash, to help any troubleshooting thereof.</p>
<p>Beyond being able to collect traces about the behaviour of the driver, Seaplus more generally supports <strong>general-purpose logging</strong> thanks to its use of Myriad's <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/src/utils/trace_bridge.erl">trace_bridge</a> (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/test/utils/trace_bridge_test.erl">trace_bridge_test.erl</a> for an usage example thereof). This means that by default these messages will be output on the console (thanks to <tt class="docutils literal">trace_utils</tt>), yet that any more advanced compliant trace system can be used instead (see <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Traces/blob/master/test/trace_bridging_test.erl">trace_bridging_test.erl</a> for an usage example thereof). So any library that is made available through Seaplus should be able to integrate nicely into one's logging system of choice.</p>
</div>
<div class="section" id="customising-function-bindings-on-the-erlang-side">
<h2><a class="toc-backref" href="#toc-entry-11">Customising Function Bindings on the Erlang Side</a></h2>
<p>We saw that, by default, no specific implementation is to be provided by the user in order to include a set of Erlang-level functions into a binding - this implementation is generated by Seaplus, and the required conversions are to be done (only) in the driver, i.e. on the C side.</p>
<p>However, in some cases, it may be convenient to perform transformations as well on the Erlang side, before and/or after that bridge, for example to adapt parameters or results, or to throw relevant exceptions instead of tagged tuples.</p>
<p>Taking <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Mobile/blob/master/src/mobile.erl">this service</a> as an example, we can see that the <tt class="docutils literal">get_backend_information/0</tt> function is to return a version number that would be ideally a triplet (e.g. <tt class="docutils literal">{1,40,0}</tt>) so that we can compare versions easily. However the C-side happens to obtain that version from the original service as a string (e.g. <tt class="docutils literal">&quot;1.40.0&quot;</tt>). The parsing/conversion of that string into a relevant version triplet could be done in C (by building by steps a corresponding term), but it may be more convenient to do so in Erlang (e.g. we may already have the right logic implemented for that).</p>
<p>Similarly, <tt class="docutils literal">get_hardware_information/0</tt> may be not supported by the actual device, and one may prefer an exception to be thrown in that case rather than having to pattern-match the result of such a call against a tagged tuple like <tt class="docutils literal">{ok,Result}</tt> vs <tt class="docutils literal">{error,Error}</tt>.</p>
<p>This implies having the ability to <strong>override</strong>, on a per-function basis, the default Erlang-side implementation that would be generated by Seaplus by a user-defined one - preferably in a simple manner.</p>
<p>Fortunately, Seaplus offers a good support for that: should a user-provided <em>definition</em> of a function to bind be found in the service module (thus: in addition to its mere spec), it will be used (and a bit transformed automatically), instead of relying on the implementation that would be generated by default.</p>
<p>For that, Seaplus provides facilities to build one's custom implementation, notably the <tt class="docutils literal">seaplus:call_port_for/3</tt> function that allows to automatically trigger a call on the C driver side.</p>
<p>So the following code will trigger a call through the port and the driver, and return its result:</p>
<pre class="code erlang literal-block">
<span class="nf">get_backend_information</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nv">PortKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">get_service_port_key</span><span class="p">(),</span><span class="w">
    </span><span class="nv">FunctionDriverId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">get_function_driver_id</span><span class="p">(),</span><span class="w">
    </span><span class="p">{</span><span class="nv">Backend</span><span class="p">,</span><span class="nv">VersionString</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w">
        </span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">call_port_for</span><span class="p">(</span><span class="nv">PortKey</span><span class="p">,</span><span class="nv">FunctionDriverId</span><span class="p">,_</span><span class="nv">Args</span><span class="o">=</span><span class="p">[])</span><span class="w">
    </span><span class="c">% From here we can parse VersionString and return a triplet:</span><span class="w">
    </span><span class="p">[...]</span>
</pre>
<p>Of course, should we have instead of:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">get_backend_information</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">backend_type</span><span class="p">(),</span><span class="w"> </span><span class="n">backend_version</span><span class="p">()}.</span>
</pre>
<p>a function like:</p>
<pre class="code erlang literal-block">
<span class="p">-</span><span class="ni">spec</span><span class="w"> </span><span class="n">compute_sum</span><span class="p">(</span><span class="n">integer</span><span class="p">(),</span><span class="w"> </span><span class="nb">float</span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">float</span><span class="p">().</span>
</pre>
<p>we could override the default Seaplus implementation with a one-liner that would perform exactly the same, such as:</p>
<pre class="code erlang literal-block">
<span class="nf">compute_sum</span><span class="p">(</span><span class="nv">MyInt</span><span class="p">,</span><span class="nv">MyFloat</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">call_port_for</span><span class="p">(</span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">get_service_port_key</span><span class="p">(),</span><span class="w">
                          </span><span class="nn">seaplus</span><span class="p">:</span><span class="nf">get_function_driver_id</span><span class="p">(),</span><span class="w">
                          </span><span class="p">_</span><span class="nv">Args</span><span class="o">=</span><span class="p">[</span><span class="nv">MyInt</span><span class="p">,</span><span class="nv">MyFloat</span><span class="p">]).</span>
</pre>
<p>A user-defined implementation just has to know:</p>
<ul class="simple">
<li>what (service-specific) port key is to be used for that (needed by the binding, knowing that multiple different services may be bridged)</li>
<li>what is the function driver identifier that was allocated to that function by Seaplus</li>
</ul>
<p>These two information can respectively by obtained thanks to <tt class="docutils literal">seaplus:get_service_port_key/0</tt> and <tt class="docutils literal">seaplus:get_function_driver_id()</tt> <a class="footnote-reference" href="#footnote-7" id="footnote-reference-7">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="footnote-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-7">[7]</a></td><td>These are pseudo-functions that will be appropriately replaced at compilation-time with immediate values (thanks to the Seaplus parse transform). As a result, a rather optimal implementation will be obtained.</td></tr>
</tbody>
</table>
<p>We can see then how one can insert any (Erlang) code of interest <em>prior to</em> and/or <em>after</em> the call to the binding bridge.</p>
<p>Not to mention that, on the C side, thanks to the service-specific driver, the same freedom exists as well: a call to the integrated library may be wrapped between any kind of pre/post transformations.</p>
<p>As a result, if needed, any mix of Erlang and C can be used to wrap any call to a library function made available through the binding.</p>
</div>
<div class="section" id="debugging-a-seaplus-based-driver">
<h2><a class="toc-backref" href="#toc-entry-12">Debugging a Seaplus-based Driver</a></h2>
<p>Integrating C code is not so easy; more often than not, a SEGV will be encountered, and the fun begins in order to determine whom to blame, typically your integration code (possible), Seaplus (possible as well) or the integrated library itself (often less likely).</p>
<p>The situation is never hopeless, though; we will take the integration of the <a class="reference external" href="https://wammu.eu/libgammu/">libgammu</a> library done by <a class="reference external" href="http://mobile.esperide.org">Ceylan-Mobile</a> on Arch Linux as a (slightly edited) mini-tutorial.</p>
<p>The type of errors that we want to track down are reported as such (real-life example of the execution of <tt class="docutils literal">mobile_test</tt> while the Seaplus driver-level facilities was incorrectly dealing, memory-wise, with the parameters that were binary strings):</p>
<pre class="code literal-block">
[...]
[debug] Driver check successful, returned 'This is a Ceylan-Seaplus driver generated for service Ceylan-Mobile. It is not meant to be executed by itself, but to be run by the Erlang-based Seaplus integration logic. Exiting now.'.
[debug] DriverCommand: '/__w/Ceylan-Mobile/Ceylan-Mobile/src/mobile_seaplus_driver'.
[debug] Storing port #Port&lt;0.10&gt; under the service key '_seaplus_port_for_service_mobile' in the process dictionary of &lt;0.9.0&gt;.
[debug] Starting Mobile.

[...]
[longer session is going smoothly when...]

Sent first SMS whose report is: {success,255}.

&lt;----------------
Error:  Crash of the driver port (#Port&lt;0.10&gt;) reported to calling process &lt;0.9.0&gt; (no reason was specified).
----------------&gt;

[info] Library dependencies for '/__w/Ceylan-Mobile/Ceylan-Mobile/src/mobile_seaplus_driver' are:
  linux-vdso.so.1 (0x00007ffd62ddc000)
  libseaplus-1.0.3.so =&gt; /__w/Ceylan-Mobile/Ceylan-Mobile/_build/default/lib/seaplus/src/libseaplus-1.0.3.so (0x00007f49027d7000)
  libGammu.so.8 =&gt; /usr/lib/libGammu.so.8 (0x00007f4902649000)
  libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f49024c6000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4902305000)
  libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f49022e4000)
  libglib-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0 (0x00007f49021c5000)
  libbluetooth.so.3 =&gt; /usr/lib/x86_64-linux-gnu/libbluetooth.so.3 (0x00007f490219c000)
  libusb-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libusb-1.0.so.0 (0x00007f4901f83000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f4902802000)
  libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f4901f0f000)
  libudev.so.1 =&gt; /lib/x86_64-linux-gnu/libudev.so.1 (0x00007f4901ee9000)
  librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f4901edf000)
While being in '/__w/Ceylan-Mobile/Ceylan-Mobile/test':
  PATH is '/__w/Ceylan-Mobile/Ceylan-Mobile/src:/usr/local/lib/erlang/erts-11.1.4/bin:/usr/local/lib/erlang/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  LD_LIBRARY_PATH is '/__w/Ceylan-Mobile/seaplus/src:/__w/Ceylan-Mobile/Ceylan-Mobile/_build/default/lib/seaplus/src'.
&quot;init terminating in do_boot&quot;,{{nocatch,{driver_crashed,unknown_reason}},[{seaplus,call_port_for,3,[{file,&quot;seaplus.erl&quot;},{line,705}]},{mobile,get_backend_information,0,[{file,&quot;mobile.erl&quot;},{line,420}]},{mobile_test,run,0,[{file,&quot;mobile_test.erl&quot;},{line,80}]},{erl_eval,do_apply,6,[{file,&quot;erl_eval.erl&quot;},{line,680}]},{init,start_it,1,[]},{init,start_em,1,[]},{init,do_boot,3,[]}]}}
</pre>
<p>So the driver crashed, we do not know precisely why (yet at least some key library information is given), and, as we will see, with such problems not so many relevant information can be found in the Seaplus driver log (i.e. in <tt class="docutils literal"><span class="pre">seaplus-driver.*.log</span></tt>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The fact that such a driver log simply exists already means that this driver could be launched at all, which is a first good news.</p>
<p>Indeed, if Seaplus checks whether the driver can be found (e.g. the <tt class="docutils literal">PATH</tt> environment variable may not be adequate) and is executable, a classical problem is that this driver may still fail to start because at least one of the shared libraries it relies upon cannot be found - typically because the <tt class="docutils literal">LD_LIBRARY_PATH</tt> environment variable has not been properly set (see <tt class="docutils literal">mobile_test</tt> for an example on how to deal with these topics). This is either the Seaplus library (<tt class="docutils literal"><span class="pre">libseaplus-x.y.z.so</span></tt>) that is lacking, and/or an integrated one (like <tt class="docutils literal">libGammu.so.x</tt> here).</p>
<p class="last">To better investigate such issues, now, if the <tt class="docutils literal">seaplus_check_driver</tt> compile flag is enabled (see <tt class="docutils literal">SEAPLUS_CHECK_FLAGS</tt> in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/GNUmakevars.inc">GNUmakevars.inc</a>), then any generated Seaplus driver is automatically tested first like if it was just a basic executable that performs a simple console output and exits immediately afterwards. Once the driver proved that way that it can be launched successfully (e.g. no lacking library dependency in the current setting), then only it is used by Seaplus as a port to interact with. This procedure is fully transparent to the Seaplus user.</p>
</div>
<p>Indeed these driver logs (in <tt class="docutils literal"><span class="pre">seaplus-driver.1037076.log</span></tt> here) tell us:</p>
<pre class="code literal-block">
[2021/2/14 12:09:21][debug] Logger for Seaplus driver: starting new session...
[2021/2/14 12:09:21][debug] Starting the Seaplus C driver, with an input buffer of 32768 bytes.
[2021/2/14 12:09:21][trace] &lt;Ceylan-Seaplus driver for service Ceylan-Mobile now running&gt;
[2021/2/14 12:09:21][debug] Starting Gammu.
[2021/2/14 12:09:21][debug] Directing Gammu logs to Seaplus ones.
[2021/2/14 12:09:21][debug] No Gammu state machine logs requested.
[...]
[2021/2/14 12:09:21][debug] Reading a new command, from address 0x7ffda4845258.
[2021/2/14 12:09:21][debug] 2 bytes to read.
[2021/2/14 12:09:21][debug] 2 bytes actually read.
[2021/2/14 12:09:21][debug] Read 2 bytes.
[2021/2/14 12:09:21][debug] Command payload to read: 6 bytes.
[2021/2/14 12:09:21][debug] 6 bytes to read.
[2021/2/14 12:09:21][debug] 6 bytes actually read.
[2021/2/14 12:09:21][debug] Read 6 bytes.
[2021/2/14 12:09:21][trace] New command received.
[2021/2/14 12:09:21][trace] Getting function information.
[2021/2/14 12:09:21][debug] Read Erlang binary term format version number: 131, from index 1.
[2021/2/14 12:09:21][debug] Reading command: function identifier is 16 (index is 5).
[2021/2/14 12:09:21][debug] Normal list found at index 6, having 4 element(s).
[2021/2/14 12:09:21][debug] 4 parameter(s) received for this function.
[2021/2/14 12:09:21][trace] Function information obtained.
[2021/2/14 12:09:21][debug] Function identifier is 16, arity is 4 (new index is 6).
[2021/2/14 12:09:21][debug] Executing send_multipart_sms/4.
[2021/2/14 12:09:21][debug] Will write 29 bytes.
[...]
</pre>
<p>We nevertheless know which API function was called when the crash happened (should you have left the corresponding <tt class="docutils literal">LOG_DEBUG</tt> calls in your driver of course) - which is already a precious information.</p>
<p>A first difficulty is that generally a (Linux) distribution will, at least by default, only include prebuilt binary packages whose libraries are stripped. For example:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>file<span class="w"> </span>/usr/lib/libGammu.so.8.1.40.0<span class="w">
</span>/usr/lib/libGammu.so.8.1.40.0:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>shared<span class="w"> </span>object,<span class="w"> </span>x86-64,<span class="w"> </span><span class="se">\
</span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>dynamically<span class="w"> </span>linked,<span class="w"> </span>BuildID<span class="o">[</span>sha1<span class="o">]=[</span>...<span class="o">]</span>,<span class="w"> </span>stripped
</pre>
<p>We <em>need</em> the debug symbols, otherwise we will lack much crucial information. Either your distribution provides a way of having unstripped, debug/development versions of some libraries, or you find it simpler and less system-jeopardizing to recompile your own unstripped versions, directly in your user account.</p>
<p>We go for the latter, for example with:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>mkdir<span class="w"> </span>~/Software/libgammu<span class="w">
</span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>~/Software/libgammu<span class="w">
</span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/gammu/gammu.git<span class="w">
</span>$<span class="w"> </span>./configure<span class="w"> </span>--enable-shared<span class="w"> </span>--enable-debug<span class="w"> </span>--enable-protection<span class="w"> </span><span class="se">\
</span><span class="w">   </span>--prefix<span class="o">=</span>~/Software/libgammu<span class="w">
</span>$<span class="w"> </span>make<span class="w"> </span>all<span class="w"> </span>install<span class="w">
</span>$<span class="w"> </span>file<span class="w"> </span>lib/libGammu.so.8.1.40.0<span class="w">
</span>lib/libGammu.so.8.1.40.0:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>shared<span class="w"> </span>object,<span class="w"> </span>x86-64,<span class="w"> </span><span class="se">\
</span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>dynamically<span class="w"> </span>linked,<span class="w"> </span>BuildID<span class="o">[</span>sha1<span class="o">]=[</span>...<span class="o">]</span>,<span class="w"> </span>with<span class="w"> </span><span class="se">\
</span>debug_info,<span class="w"> </span>not<span class="w"> </span>stripped
</pre>
<p>Same version number - yet much better for debugging!</p>
<p>Now, provided that the Seaplus driver points to the right library, we should benefit from debug symbols.</p>
<p>A first option would be to run the driver through <a class="reference external" href="https://www.gnu.org/software/gdb/">gdb</a> (e.g. <tt class="docutils literal">gdb <span class="pre">-batch</span> <span class="pre">-ex</span> run mobile_seaplus_driver</tt>) when triggered by the application, yet we had not much luck with that approach.</p>
<p>Examining instead the core dump corresponding to the driver crash may offer relevant insights; provided that we find it and manage to study it.</p>
<p>In our case we used (as a one-liner), from the test directory, once a crash had been triggered, the following commands:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>rm<span class="w"> </span>-f<span class="w"> </span>mobile_seaplus.core*<span class="w">
</span>$<span class="w"> </span>cp<span class="w"> </span>/var/lib/systemd/coredump/core.mobile_seaplus*<span class="w"> </span>mobile_seaplus.core.lz4<span class="w">
</span>$<span class="w"> </span>lz4<span class="w"> </span>mobile_seaplus.core.lz4<span class="w">
</span>$<span class="w"> </span>gdb<span class="w"> </span>mobile_seaplus_driver
</pre>
<p>Following gdb command would then bring new information:</p>
<pre class="code literal-block">
(gdb) core mobile_seaplus.core
warning: core file may not match specified executable file.
[New LWP 11607]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.
Core was generated by `./mobile_seaplus_driver'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007f894b2a5a26 in malloc () from /usr/lib/libc.so.6

(gdb) bt full
#0  0x00007f894b2a5a26 in malloc () from /usr/lib/libc.so.6
No symbol table info available.
#1  0x00007f894b432742 in GSM_PackSemiOctetNumber (Number=Number&#64;entry=0x55822a55d68c &lt;sms+172&gt; &quot;&quot;, Output=Output&#64;entry=0x7ffe3a9f20f2 &quot;&quot;,
  semioctet=semioctet&#64;entry=1) at [...]/libgammu/misc/coding/coding.c:1168
      format = &lt;optimized out&gt;
      length = 12
      i = &lt;optimized out&gt;
      skip = 0
[...]

(gdb) frame 2
#2  0x00007f7189618329 in GSM_EncodeSMSFrame () from /usr/lib/libGammu.so.8
(gdb) bt
#0  0x00007f7189305a26 in malloc () from /usr/lib/libc.so.6
[...]
</pre>
<p>While often useful, the debugger just tells us here that the SIGSEGV happened in a malloc that looks perfectly legit, and done by the inner workings of Gammu. We suspect that this library is not involved, but that we managed somehow to smash the heap in previous operations. Definitively not a good news!</p>
<p>So now it is time to use use <a class="reference external" href="http://valgrind.org/">Valgrind</a> in order to investigate this possible error in memory management.</p>
<p>One should then have a look to the <tt class="docutils literal">init_driver/2</tt> function of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/src/seaplus.erl">seaplus.erl</a> module, to uncomment the <tt class="docutils literal">DriverCommand</tt> variation involving Valgrind.</p>
<p>Once using a Valgrind-based driver command and an updated environment (to select your debug library rather than the system's one), when looking at the specified log file (<tt class="docutils literal"><span class="pre">/tmp/seaplus-valgrind.log</span></tt>) you should end up with a report like:</p>
<pre class="code literal-block">
==12257== Invalid read of size 1
==12257==    at 0x483AC74: strlen (vg_replace_strmem.c:460)
==12257==    by 0x10ACBE: main (mobile_seaplus_driver.c:438)
==12257==  Address 0x51b186c is 0 bytes after a block of size 12 alloc'd
==12257==    at 0x483777F: malloc (vg_replace_malloc.c:299)
==12257==    by 0x484DD28: erl_malloc (erl_malloc.c:234)
==12257==    by 0x484EF9A: erl_decode_it (erl_marshal.c:1041)
==12257==    by 0x484F19A: erl_decode_it (erl_marshal.c:959)
==12257==    by 0x484EE88: erl_decode_it (erl_marshal.c:1018)
==12257==    by 0x485042C: erl_decode (erl_marshal.c:1111)
==12257==    by 0x484B406: read_function_information (seaplus.c:498)
==12257==    by 0x10A7D1: main (mobile_seaplus_driver.c:245)
</pre>
<p>We were reading the content of a binary like if it was a zero-terminated char * (and moreover we used to wrongly take ownership of that buffer).</p>
<p>So neither the Ceylan-Mobile integration nor Gammu were the culprits, it was a Seaplus bug (of course fixed since then)!</p>
<p>Hopefully with this example one will be less afraid to hack around shared libraries (especially if they are open source): for each problem there are surely means of investigation - no rocket science involved.</p>
</div>
<div class="section" id="testing-seaplus-1">
<h2><a class="toc-backref" href="#toc-entry-13">Testing Seaplus</a></h2>
<p>Once <a class="reference external" href="https://myriad.esperide.org">Myriad</a> and Seaplus itself have been built (for that refer to either <a class="reference internal" href="#using-cutting-edge-git">Using Cutting-Edge GIT</a> or <a class="reference internal" href="#using-rebar3">Using Rebar3</a>), just run from the root directory of Seaplus:</p>
<pre class="code bash literal-block">
$<span class="w"> </span>make<span class="w"> </span><span class="nb">test</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Seaplus is built and tested at each commit through <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/actions?query=workflow%3A%22Erlang+CI%22">continuous integration</a>, and the same holds for its only prerequisite (<a class="reference external" href="https://myriad.esperide.org">Myriad</a>).
Reciprocally this procedure applies to the projects based on it (e.g. <a class="reference external" href="https://mobile.esperide.org/">Mobile</a>), so in terms of usability, at least some confidence should exist.</p>
</div>
</div>
<div class="section" id="towards-a-more-general-c-c-interface">
<h2><a class="toc-backref" href="#toc-entry-14">Towards a more General C/C++ Interface</a></h2>
<p>Functionally, <a class="reference external" href="http://erlang.org/doc/man/ei.html">ei</a> (not to mention <a class="reference external" href="http://erlang.org/doc/apps/erl_interface/">Erl_Interface</a>) and the <a class="reference external" href="http://erlang.org/doc/man/erl_nif.html">Erlang NIF support</a> (see also <a class="reference external" href="https://howtos.esperide.org/Erlang.html#nif">this section</a> of our HOWTO) provide the same services, and <strong>could probably be unified under a common API</strong> (that one day Seaplus could provide).</p>
<p>This could enable the possibility of integrating the same C/C++ code seamlessly as a C-Node and/or as a NIF, for a greater flexibility of use.</p>
</div>
<div class="section" id="c-c-code-formatting">
<h2><a class="toc-backref" href="#toc-entry-15">C/C++ Code Formatting</a></h2>
<p>In some cases, integrating a C/C++ open source library leads to forking it, typically to correct/add elements. Then starting by applying cosmetic changes such as whitespace cleanup (see the <tt class="docutils literal"><span class="pre">fix-whitespaces*.sh</span></tt> scripts in <a class="reference external" href="https://hull.esperide.org/#to-fix-names-paths-permissions-content">this section</a> of Ceylan-Hull) and proper code formatting may be useful.</p>
<p>For this last topic, we generally rely on <a class="reference external" href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> and enforce the LLVM coding style. For that, we install the <tt class="docutils literal"><span class="pre">clang-format-static-bin</span></tt> Arch AUR package and run it like: <tt class="docutils literal"><span class="pre">clang-format</span> <span class="pre">--style=LLVM</span> <span class="pre">-i</span> *.c *.h</tt>, to perform in-place reformatting.</p>
</div>
</div>
<div class="section" id="issues-planned-enhancements">
<h1><a class="toc-backref" href="#toc-entry-16">Issues &amp; Planned Enhancements</a></h1>
<ul class="simple">
<li>thorough testing of the C-side should be done, notably with regard to the hunt for memory leaks; so the <a class="reference external" href="http://valgrind.org/">Valgrind-based</a> runtime mode for the driver is surely be useful and should be tested on a regular basis (note though that, when <tt class="docutils literal">Erl_Interface</tt> was used prior to <tt class="docutils literal">ei</tt>, <tt class="docutils literal">erl_eterm_statistics/2</tt> and <tt class="docutils literal">erl_eterm_release/0</tt> were used to monitor these issues at runtime, in debug mode - in order to ensure that on the C side no term was ever leaked)</li>
</ul>
<p></p>
</div>
<div class="section" id="support">
<h1><a class="toc-backref" href="#toc-entry-17">Support</a></h1>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent through the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus">project interface</a>, or directly at the email address mentioned at the beginning of this document.</p>
</div>
<div class="section" id="seaplus-inner-workings">
<h1><a class="toc-backref" href="#toc-entry-18">Seaplus Inner Workings</a></h1>
<p>It is mostly the one described in the <a class="reference external" href="http://erlang.org/doc/tutorial/erl_interface.html">Erl_Interface</a> tutorial, once switched to <tt class="docutils literal">ei</tt> (another source of inspiration has been <a class="reference external" href="https://erlangcentral.org/wiki/How_to_use_ei_to_marshal_binary_terms_in_port_programs">this article</a>) and augmented with conventions and automated by the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Seaplus/blob/master/src/seaplus_parse_transform.erl">Seaplus parse transform</a> as much as realistically possible (hence a code generation that is exhaustive on the Erlang side, and partial of the C side) and adapted for increased performances (notably: no extra relay process between the user code and the port involving more messages and processing, no string-based mapping of function signatures across the bridge - direct integer identifiers used instead).</p>
<p>The parse transform just:</p>
<ul class="simple">
<li>derives from the type specifications of the Erlang service API (as specified by the service integrator) the implementation of the corresponding (Erlang-side) functions (unless already available, their proper definitions are injected in the AST of the resulting service BEAM file, and they are exported)</li>
<li>adds the facility functions to start, stop, etc. that service (they are actually directly obtained through the Seaplus include)</li>
<li>generates the Seaplus service-specific C header file, ready to be included by the C-side service driver that is to be filled by the service integrator, based on the C template that is also generated in a proper version</li>
</ul>
<p>As of June 2019, and related to the release of Erlang 22.0, we had to switch from the <tt class="docutils literal">Erl_Interface</tt> API (now made obsolete) to the lower-level <tt class="docutils literal">ei</tt> one (one may refer to the <tt class="docutils literal">update_to_ei</tt> branch for that; for reference, the last version relying on <tt class="docutils literal">Erl_Interface</tt>, which was working great, has been marked with the <tt class="docutils literal">before_switch_to_ei</tt> tag).</p>
<p>A problem apparently induced by the direct use of <tt class="docutils literal">ei</tt> is that, due to <tt class="docutils literal">term_to_binary/1</tt> mistaking the <tt class="docutils literal"><span class="pre">[0..255]</span></tt> type for the <tt class="docutils literal">string()</tt> one, such lists had to be special-cased, which is not so straightforward to support in a generic manner (like with Seaplus). The whole is correctly supported by Seaplus now.</p>
</div>
<div class="section" id="please-react">
<h1><a class="toc-backref" href="#toc-entry-19">Please React!</a></h1>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, drop us a line! (for that, follow the <a class="reference internal" href="#support">Support</a> guidelines).</p>
</div>
<div class="section" id="ending-word">
<h1><a class="toc-backref" href="#toc-entry-20">Ending Word</a></h1>
<p>Have fun with Ceylan-Seaplus!</p>
<p><span class="raw-html"><center><img src="seaplus-title.png" id="responsive-image-small"></img></center></span>
</p>
<p><span class="raw-html"><a name="seaplus_bottom"></a></span></p>
</div>
</div>
</body>
</html>
