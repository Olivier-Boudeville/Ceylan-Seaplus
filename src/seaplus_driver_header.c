

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * '##SEAPLUS_SERVICE_NAME##' service API, the Erlang parameters received from
 * the port into C variables that can be passed to the service functions, and to
 * perform the reciprocal operation on their results, so that they can be sent
 * back to the Erlang calling side.
 *
 */


/* Generated by the Seaplus parse transform, based on
 * ##SEAPLUS_SERVICE_NAME##.erl:
 *
 */
#include "##SEAPLUS_SERVICE_HEADER_FILE##"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


/* To access the actual C implementation of the service:
 *
 * (this is an example; depending on the integrated library, such a header may
 * or may not exist with this specific name - adapt to your liking)
 *
 */
#include "##SEAPLUS_SERVICE_NAME##.h"


// For free:
#include <stdlib.h>

// For printf:
#include <stdio.h>


int main( int argc, char *argv[] )
{

  /* Notably useful to perform a first check that all library dependencies are
   * satisfied:
   *
   */
  if ( argc != 1 )
  {
	printf( "This is a Ceylan-Seaplus driver generated for service "
	  "##SEAPLUS_SERVICE_NAME##. It is not meant to be executed by itself, "
	  "but to be run by the Erlang-based Seaplus integration logic. "
	  "Exiting now.\n" ) ;

	return EXIT_SUCCESS ;

  }

  printf( "<Ceylan-Seaplus driver for service ##SEAPLUS_SERVICE_NAME## "
	"now running>\n" ) ;

  // Provided by the Seaplus library:
  byte * current_read_buf ;

  input_buffer read_buf = &current_read_buf ;

  start_seaplus_driver( read_buf ) ;

  // For the mandatory result:
  output_buffer output_sm_buf ;

  LOG_TRACE( "##SEAPLUS_SERVICE_NAME## driver started." ) ;

  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( read_buf ) > 0 )
  {

	LOG_TRACE( "New command received." ) ;

	// Current index in the input buffer (for decoding purpose):
	buffer_index index = 0 ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;

	read_function_information( read_buf, &index, &current_fun_id,
	  &param_count ) ;

	LOG_DEBUG( "Function identifier is %u, arity is %u (new index is %u).",
	  current_fun_id, param_count, index ) ;

	prepare_for_command( &output_sm_buf ) ;


	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{
