/*
 * Copyright (C) 2018-2019 Olivier Boudeville
 *
 * This file is part of the Ceylan-Seaplus library.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License or
 * the GNU General Public License, as they are published by the Free Software
 * Foundation, either version 3 of these Licenses, or (at your option)
 * any later version.
 * You can also redistribute it and/or modify it under the terms of the
 * Mozilla Public License, version 1.1 or later.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License and the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License, of the GNU General Public License and of the Mozilla Public License
 * along with this library.
 * If not, see <http://www.gnu.org/licenses/> and
 * <http://www.mozilla.org/MPL/>.
 *
 * Author: Olivier Boudeville [olivier (dot) boudeville (at) esperide (dot) com]
 * Creation date: Sunday, December 16, 2018
 *
 */



/*
 * C example Seaplus driver around the toy foobar library, giving access to its
 * API, i.e. to the functions declared in foobar.h (and defined on foobar.c).
 *
 * The messages from and to Erlang use a mapping to identify the (Erlang)
 * functions whose type specification was devised by the service
 * integrator. This mapping is made explicit by the foobar_seaplus_api_mapping.h
 * header file, generated by Seaplus.
 *
 * Directly inspired from:
 * http://erlang.org/doc/tutorial/erl_interface.html#c-program
 *
 */


// Expected to be generated by the Seaplus parse transform, based on foobar.erl:
#include "foobar_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the service:
#include "foobar.h"


// For exit:
#include <stdlib.h>


int main()
{

  // Provided by the Seaplus library:
  byte * buffer = start_seaplus_driver() ;

  // Pointer to an ETERM representing a tuple:
  ETERM * readPair ;

  // To hold a Seaplus-defined function identifier (ex: FOO_1_ID):
  fun_id funId ;

  // Reads a full command from (receive) buffer, based on its initial length:
  while ( read_seaplus_command( buffer ) > 0 )
  {

	/*
	 * Reads a { FunId, FunParams } pair thanks to Erl_Interface:
	 *
	 * (see http://erlang.org/doc/man/erl_marshal.html#erl_decode)
	 *
	 */
	readPair = erl_decode( buffer ) ;

	if ( readPair == NULL )
	{

	  	LOG_ERROR( "Decoding of the command from the receive buffer failed." ) ;
		return (-1) ;

	}


	/* Note that all parameters must be read (with a get_* function, even if
	 * their actual value is ignored), otherwise their memory will be leaked.
	 */

	// First element of the pair is the function identifier:
	funId = get_as_unsigned_int( 1, readPair ) ;

	LOG_DEBUG( "Reading command: function identifier is %u.", funId ) ;

	switch( funId )
	{

	case FOO_1_ID:
	  // Second one is its (single, int) parameter:
	  int fooIntParam = get_as_int( 2, readPair ) ;
	  int fooResult = foo( fooIntParam ) ;
	  write_as_int( buffer, readPair, fooResult  ) ) ;
	  break ;

	case BAR_2_ID:
	  // Second and third are its two int parameters:
	  write_as_int( buffer, readPair, bar( get_as_int( 2, readPair ),
										  get_as_int( 3, readPair ) ) ) ;
	  break ;

	case BAZ_2_ID:
	  // Second one is its (single, float) parameter:
	  write_as_string( buffer, readPair,
					   baz( (float) get_as_double( 2, readPair ) ) ) ;
	  break ;

	case TUR_0_ID:
	  // Second one is its (single, string) parameter:
	  write_as_unsigned_int( buffer, readPair,
							 tur( get_as_string( 2, readPair ) ) ) ;
	  break ;

	case FROB_1_ID:
	  // Second one is its (single, string) parameter:
	  write_as_binary( buffer, readPair,
					   frob( get_as_string( 2, readPair ) ) ) ;
	  break ;

	default:
	  LOG_ERROR( "Unknown function identifier: %u", funId ) ;
	  exit( 10 ) ;

	}
	
	erl_free_compound( readPair ) ;
	
  }

  stop_seaplus_driver( buffer ) ;

}
