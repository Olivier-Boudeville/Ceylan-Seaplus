

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * 'foobar' service API, the Erlang parameters received from
 * the port into C variables that can be passed to the service functions, and to
 * perform the reciprocal operation on their results, so that they can be sent
 * back to the Erlang calling side.
 *
 */


/* Generated by the Seaplus parse transform, based on
 * foobar.erl:
 *
 */
#include "foobar_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


/* To access the actual C implementation of the service:
 *
 * (this is an example; depending on the integrated library, such a header may
 * or may not exist with this specific name - adapt to your liking)
 *
 */
#include "foobar.h"


// For free:
#include <stdlib.h>

// For printf:
#include <stdio.h>


int main( int argc, char *argv[] )
{

  /* Notably useful to perform a first check that all library dependencies are
   * satisfied:
   *
   */
  if ( argc != 1 )
  {
	printf( "This is a Ceylan-Seaplus driver generated for service "
	  "foobar. It is not meant to be executed by itself, "
	  "but to be run by the Erlang-based Seaplus integration logic. "
	  "Exiting now.\n" ) ;

	return EXIT_SUCCESS ;

  }

  printf( "<Ceylan-Seaplus driver for service foobar "
	"now running>\n" ) ;

  // Provided by the Seaplus library:
  byte * current_read_buf ;

  input_buffer read_buf = &current_read_buf ;

  start_seaplus_driver( read_buf ) ;

  // For the mandatory result:
  output_buffer output_sm_buf ;

  LOG_TRACE( "foobar driver started." ) ;

  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( read_buf ) > 0 )
  {

	LOG_TRACE( "New command received." ) ;

	// Current index in the input buffer (for decoding purpose):
	buffer_index index = 0 ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;

	read_function_information( read_buf, &index, &current_fun_id,
	  &param_count ) ;

	LOG_DEBUG( "Function identifier is %u, arity is %u (new index is %u).",
	  current_fun_id, param_count, index ) ;

	prepare_for_command( &output_sm_buf ) ;


	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{

	case FOO_1_ID:

		LOG_DEBUG( "Executing foo/1." ) ;
		check_arity_is( 1, param_count, FOO_1_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of
		// interest (refer to seaplus_getters.h for the conversion functions).

		// As an example, supposing that a single input parameter of type 'int'
		// applies for this foo/1 function:
		// int i = read_int_parameter( read_buf, &index ) ;

		// This allows then to call the C counterpart of
		// the foo/1 function:
		// For example float f = some_service_function( i ) ;

		// Then write the returned result to the Erlang side:
		// (refer to seaplus_setters.h for the conversion functions)
		// For example write_double_result( &output_sm_buf, (double) f ) ;

		// Do not forget to deallocate any relevant memory!
		// (refer to foobar_seaplus_driver.c for an example)

		break ;


	case BAR_2_ID:

		LOG_DEBUG( "Executing bar/2." ) ;
		check_arity_is( 2, param_count, BAR_2_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of
		// interest (refer to seaplus_getters.h for the conversion functions).

		// As an example, supposing that a single input parameter of type 'int'
		// applies for this bar/2 function:
		// int i = read_int_parameter( read_buf, &index ) ;

		// This allows then to call the C counterpart of
		// the bar/2 function:
		// For example float f = some_service_function( i ) ;

		// Then write the returned result to the Erlang side:
		// (refer to seaplus_setters.h for the conversion functions)
		// For example write_double_result( &output_sm_buf, (double) f ) ;

		// Do not forget to deallocate any relevant memory!
		// (refer to foobar_seaplus_driver.c for an example)

		break ;


	case BAZ_2_ID:

		LOG_DEBUG( "Executing baz/2." ) ;
		check_arity_is( 2, param_count, BAZ_2_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of
		// interest (refer to seaplus_getters.h for the conversion functions).

		// As an example, supposing that a single input parameter of type 'int'
		// applies for this baz/2 function:
		// int i = read_int_parameter( read_buf, &index ) ;

		// This allows then to call the C counterpart of
		// the baz/2 function:
		// For example float f = some_service_function( i ) ;

		// Then write the returned result to the Erlang side:
		// (refer to seaplus_setters.h for the conversion functions)
		// For example write_double_result( &output_sm_buf, (double) f ) ;

		// Do not forget to deallocate any relevant memory!
		// (refer to foobar_seaplus_driver.c for an example)

		break ;


	case TUR_0_ID:

		LOG_DEBUG( "Executing tur/0." ) ;
		check_arity_is( 0, param_count, TUR_0_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of
		// interest (refer to seaplus_getters.h for the conversion functions).

		// As an example, supposing that a single input parameter of type 'int'
		// applies for this tur/0 function:
		// int i = read_int_parameter( read_buf, &index ) ;

		// This allows then to call the C counterpart of
		// the tur/0 function:
		// For example float f = some_service_function( i ) ;

		// Then write the returned result to the Erlang side:
		// (refer to seaplus_setters.h for the conversion functions)
		// For example write_double_result( &output_sm_buf, (double) f ) ;

		// Do not forget to deallocate any relevant memory!
		// (refer to foobar_seaplus_driver.c for an example)

		break ;


	case FROB_1_ID:

		LOG_DEBUG( "Executing frob/1." ) ;
		check_arity_is( 1, param_count, FROB_1_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of
		// interest (refer to seaplus_getters.h for the conversion functions).

		// As an example, supposing that a single input parameter of type 'int'
		// applies for this frob/1 function:
		// int i = read_int_parameter( read_buf, &index ) ;

		// This allows then to call the C counterpart of
		// the frob/1 function:
		// For example float f = some_service_function( i ) ;

		// Then write the returned result to the Erlang side:
		// (refer to seaplus_setters.h for the conversion functions)
		// For example write_double_result( &output_sm_buf, (double) f ) ;

		// Do not forget to deallocate any relevant memory!
		// (refer to foobar_seaplus_driver.c for an example)

		break ;


	default:
	  raise_error( "Unknown function identifier: %u", current_fun_id ) ;

	}

	finalize_command_after_writing( &output_sm_buf ) ;

  }

  // output_sm_buf internally already freed appropriately.

  stop_seaplus_driver( read_buf ) ;

}
