

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * '##SEAPLUS_SERVICE_NAME##' service API, the Erlang parameters received from the port into
 * C variables that can be passed to the service functions, and to perform the
 * reciprocal operation on their results, so that they can be sent back to the
 * Erlang calling side.
 *
 */


// Generated by the Seaplus parse transform, based on ##SEAPLUS_SERVICE_NAME##.erl:
#include "##SEAPLUS_SERVICE_HEADER_FILE##"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the service:
#include "##SEAPLUS_SERVICE_NAME##.h"


// For exit:
#include <stdlib.h>


int main()
{

  // Provided by the Seaplus library:
  byte * buffer = start_seaplus_driver() ;

  LOG_TRACE( "Driver started." ) ;

  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( buffer ) > 0 )
  {

	//LOG_TRACE( "New command received." ) ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;


	// Array containing, in-order, the (param_count) transmitted parameters:
	ETERM ** parameters = NULL ;

	ETERM * call_term = get_function_information( buffer, &current_fun_id,
	  &param_count, &parameters ) ;

	/*
	LOG_DEBUG( "Function identifier is %u, arity is %u.", current_fun_id,
	  param_count ) ;
	 */

	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{
