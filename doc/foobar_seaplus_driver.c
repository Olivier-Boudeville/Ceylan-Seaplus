

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * foobar service API, the Erlang parameters received from the
 * port into C variables that can be passed to the service functions, and to
 * perform the reciprocal operation on their results, so that they can be sent
 * back to the Erlang calling side.
 *
 */


// Generated by the Seaplus parse transform, based on foobar.erl:
#include "foobar_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the service:
#include "foobar.h"


// For exit:
#include <stdlib.h>


int main()
{

  // Provided by the Seaplus library:
  byte * buffer = start_seaplus_driver() ;

  LOG_TRACE( "Driver started." ) ;

  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( buffer ) > 0 )
  {

	//LOG_TRACE( "New command received." ) ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;


	// Array containing, in-order, the (param_count) transmitted parameters:
	ETERM ** parameters = NULL ;

	ETERM * call_term = get_function_information( buffer, &current_fun_id,
	  &param_count, &parameters ) ;

	/*
	LOG_DEBUG( "Function identifier is %u, arity is %u.", current_fun_id,
	  param_count ) ;
	 */

	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{

	case FOO_1_ID:

		LOG_DEBUG( "Executing foo/1." ) ;
		check_arity_is( 1, param_count, FOO_1_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of interest.
		// Add call to the C counterpart of foo/1.
		// Write the returned result to buffer.

		break ;


	case BAR_2_ID:

		LOG_DEBUG( "Executing bar/2." ) ;
		check_arity_is( 2, param_count, BAR_2_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of interest.
		// Add call to the C counterpart of bar/2.
		// Write the returned result to buffer.

		break ;


	case BAZ_2_ID:

		LOG_DEBUG( "Executing baz/2." ) ;
		check_arity_is( 2, param_count, BAZ_2_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of interest.
		// Add call to the C counterpart of baz/2.
		// Write the returned result to buffer.

		break ;


	case TUR_0_ID:

		LOG_DEBUG( "Executing tur/0." ) ;
		check_arity_is( 0, param_count, TUR_0_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of interest.
		// Add call to the C counterpart of tur/0.
		// Write the returned result to buffer.

		break ;


	case FROB_1_ID:

		LOG_DEBUG( "Executing frob/1." ) ;
		check_arity_is( 1, param_count, FROB_1_ID ) ;

		// Add an Erlang term -> C conversion here for each parameter of interest.
		// Add call to the C counterpart of frob/1.
		// Write the returned result to buffer.

		break ;


	default:
	  raise_error( "Unknown function identifier: %u", current_fun_id ) ;

	}

	clean_up_command( call_term, parameters ) ;

  }

  stop_seaplus_driver( buffer ) ;

}
