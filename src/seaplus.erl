% This module gathers the generic elements useful to integrate any kind of
% C-based service to Erlang.
%
% Relies on Ceylan-Myriad.
%
-module(seaplus).


% Design notes:


% Examples like http://erlang.org/doc/tutorial/erl_interface.html#erlang-program
% show a design where an intermediate process is holding the port.
%
% We chose to hold the port reference directly in the user process, for more
% direct communications.


% We have to rely on a side-effect means of getting that port, as user call
% shall be as lean and mean as possible (no user-level context to keep).
%
% This could be done each thanks to a look-up in the (ex: local) name registery,
% or through a value put in the process dictionary.
%
% We went for the latter, as it is a per-process setting, as opposed to a
% per-node one, allowing for more flexibility in the number of instances
% (i.e. some services might be instantiated more than once, for example with one
% instance of them on as many user processes as needed).
%
% In all cases, Seaplus shall not interfere with any other convention (hence a
% seaplus-specific key being defined), and should allow the user code (more
% precisely: each user process) to make use of multiple Seaplus-based services
% (i.e. a service foo and a service bar from a given user process, regardless of
% the multiplicity of each of them).


% Implementation notes:
%
% Seaplus allows, from a single process, to interact with multiple
% (Seaplus-based) services.
%
% This service support depends, beyond Erlang, (only) on Ceylan-Myriad.
%
% The caller process exchanges directly with the Erlang port Seaplus spawned on
% its behalf, knowing that selective receive already allows to perform
% multiplexed, asynchronous calls and result gathering.
%
% As for the port itself, it is to interact directly (through pipe-like
% channels) with the (C-based) driver executable making the service of interest
% available to Erlang.
%
% The port referebce is stored in the process dictionary of the user process,
% for easier, more transparent management.




-export([ start/1, start_link/1, start/2, start_link/2,
		  restart/1, restart/2, stop/0,
		  get_id_for/2 ]).


% A key corresponding to the port of a service instance, whose reference is to
% be stored in the process dictionary of the user process:
%
-type service_key() :: process_dictionary:key().


% The identifier of a function for the driver, as determined by Seaplus:
%
% (ex: 1 for foo/1 in the toy example)
%
-type function_driver_id() :: basic_utils:count().


% The list of parameters to call the function stub with:
-type function_params() :: [ term() ].


% The (Erlang-side) result of the execution of a function:
-type function_result() :: term().


-export_type([ function_driver_id/0, function_params/0, function_result/0 ]).




% The name of the key in the process dictionary of the service of interest is to
% be generated by the Seaplus parse transform as well, so that it is
% service-specific (i.e. includes foobar here):
%
%-define( port_dict_key, seaplus_foobar_port_dict_key ).



% Thanks to the service_integration parse transform, a right, minimal, optimal
% API is automatically generated.
%
% More precisely, from the type specifications of the API functions, the Seaplus
% transform automatically generates:
%
% - their export: -export([ foo/1, bar/2, baz/2, tur/0, frob/1 ]).
% - their definition, like in:
%
% foo( A ) ->
%   seaplus:call_port_for( ?foobar_port_dict_key, 1, [ A ] ).
%
% bar( A, B ) ->
%   seaplus:call_port_for( ?foobar_port_dict_key, 2, [ A, B ] ).
%
% where for example 1d is the static index (compile-time, immediate value)
% chosen for foo/1 (and foobar_port_dict_key is the service-specific key of
% foobar in the user process dictionary, so that multiple Seaplus-using services can
% coexist)
%
% - the function identifier mapping, made available thanks to a
% 'foobar_seaplus_api_mapping.h' generated C header file (to be included in
% 'foobar_seapllus_driver.c') containing for example:
%
% """
%/*
% * Of course these identifiers must match their Erlang counterparts:
% *
% * ('const fun_id foo_id = 1 ;' could not be used with switch...)
% *
% */
%#define FOO_ID  1
%#define BAR_ID  2
%#define BAZ_ID  3
%#define TUR_ID  4
%#define FROB_ID 5
%
% """
%
% - all relevant utility functions transverse to all services (start/0, etc.)
%
% As a result, the service-specific Erlang part is minimal (foobar.erl mostly
% contains the type specifications of the API functions), while the C part only
% has to take care of the service-specific remaining work: demarshalling
% arguments (Erlang to C), executing the corresponding C function based on them,
% marshalling the corresponding results (C to Erlang), like in:
%
% [...]
% case FOO_ID:
%	  // Second one is its (single, int) parameter:
%	  write_as_int( buffer, paramTuple, foo( get_as_int( 2, paramTuple ) ) ) ;
%	  break ;
% [...]
%
% That'it! Thanks to these elements, user (Erlang) code shall be able to use the
% foobar service, for example:
%
% [...]
% A = foobar:foo( 42 ),
% [...]



% The name of a C-based service to make available:
-type service_name() :: atom().



% Starts the support for the specified named service.
%
% The corresponding executable driver is implicit here, so its name is expected
% to be the one of the service once suffixed with "_seaplus_driver".
%
% For example, a service 'foobar', hence having the Erlang-side bridge
% implemented in foobar.erl, is expected here to rely on the 'foobar_seaplus_driver'
% generated executable.
%
% Note: as the created port is not linked here, as a side-effect the caller
% (user) process will be set to trapping exit signals, so that EXIT messages can
% be received, and be translated to exceptions to be raised.
%
-spec start( service_name() ) -> void().
start( ServiceName ) when is_atom( ServiceName ) ->

	% Not supplied here, hence expected to match the service name:
	DriverExecName = get_driver_name( ServiceName ),

	start( ServiceName, DriverExecName ).



% Starts and links the support for the specified named service.
%
% The corresponding driver is implicit here, so its name is expected to be the
% one of the service once suffixed with "_seaplus_driver".
%
% For example, a service 'foobar', hence having the Erlang-side bridge
% implemented in foobar.erl, is expected here to rely on the 'foobar_seaplus_driver'
% generated executable.
%
% Note: as the created port is linked here, as a side-effect the caller (user)
% process will be set to *not* trapping exit signals; so it will die whenever a
% port-side problem happens.
%
-spec start_link( service_name() ) -> void().
start_link( ServiceName ) when is_atom( ServiceName ) ->

	% Not supplied here, hence expected to match the service name:
	DriverExecName = get_driver_name( ServiceName ),

	start_link( ServiceName, DriverExecName ).



% Starts the support for the specified named service, relying on specified
% executable name for the driver.
%
% Note: should the service itself or its driver crash (ex: in the context of a
% call being triggered), the service user process will receive an
% {'EXIT',FromPort,Reason} message.
%
-spec start( service_name(), file_utils:executable_name() ) -> void().
start( ServiceName, DriverExecutableName )
  when is_atom( ServiceName ) andalso is_list( DriverExecutableName ) ->

	DriverExecPath = get_driver_path( ServiceName, DriverExecutableName ),

	launch( ServiceName, DriverExecPath ).



% Starts and links to the caller the support for the specified named service,
% relying on specified executable name for the driver.
%
% Note: should the service itself or its driver crash (ex: in the context of a
% call being triggered), the service user process will receive an exit signal
% with an exit reason other than normal.
%
-spec start_link( service_name(), file_utils:executable_name() ) -> void().
start_link( ServiceName, DriverExecutableName )
  when is_atom( ServiceName ) andalso is_list( DriverExecutableName ) ->

	DriverExecPath = get_driver_path( ServiceName, DriverExecutableName ),

	launch_link( ServiceName, DriverExecPath ).


% Restarts the specific service support (ex: to overcome a detected crash
% thereof).
%
-spec restart( service_name() ) -> void().
restart( ServiceName ) ->
	stop( ServiceName ),
	start( ServiceName ).


% Restarts the specific service support (ex: to overcome a detected crash
% thereof).
%
-spec restart( service_name(), file_utils:executable_name() ) -> void().
restart( ServiceName, DriverExecutableName ) ->
	stop( ServiceName ),
	start( ServiceName, DriverExecutableName ).


% Stops the specific service support.
%
-spec stop( service_name() ) -> void().
stop( ServiceName ) when is_atom( ServiceName ) ->
	ServiceName ! stop.




% Returns the identifier for specified service-exported function.
%
% If the list of exported service functions is: [ {foo,1}, {bar,2}, {baz,1},
% {tur,1}, {frob,1} ], the identifier of a given function is its index in this
% list, like it using:
%
% -define( foo_id,  1 ).
% -define( bar_id,  2 ).
% -define( baz_id,  3 ).
% -define( tur_id,  4 ).
% -define( frob_id, 5 ).
%
% A table (hence probably some persistent state) could be relevant as well.
%
get_id_for( FunctionName, FunctionArity ) ->

	FunctionIds = list_exported_service_functions(),
	%FIXME
	try

		FunId = lists_utils:get_index_of( FunctionName, Functions ),

		trace_utils:trace_fmt( "Returning ID ~B for function '~s'.",
							   [ FunId, FunctionName ] ),

		FunId

	catch _:_ ->
		throw( { unknown_service_function, FunctionName, Functions } )

	end.


% Helper section.


% Returns the filename of the executable corresponding to specified service.
%
% (helper)
%
-spec get_driver_name( service_name() ) -> file_utils:executable_name().
get_driver_name( ServiceName ) ->
	text_utils:format( "~s_seaplus_driver", [ ServiceName ] ).



% Returns the path to the executable corresponding to specified service.
%
% (helper)
%
-spec get_driver_path( service_name(), file_utils:executable_name() ) ->
							 file_utils:executable_path().
get_driver_path( ServiceName, DriverExecutableName ) ->

	ExecPath = case executable_utils:lookup_executable( DriverExecutableName ) of

		false ->
			trace_utils:error_fmt( "Unable to find executable '~s' "
								   "for service '~s'.",
								   [ DriverExecutableName, ServiceName ] ),
			throw( { executable_not_found, DriverExecutableName, ServiceName } );

		Path ->
			Path

	end,

	trace_utils:debug_fmt( "Initializing service '~s', using executable '~s'.",
						   [ ServiceName, ExecPath ] ),

	ExecPath.



% Launches specified service support.
%
% DriverExecPath supposed already checked for existence.
%
% (helper)
%
-spec launch( service_name(, file_utils:executable_name() ) ) -> void().
launch( ServiceName, DriverExecPath ) ->

	% To receive EXIT messages, should the port fail:
	process_flag( trap_exit, true ),

	% No need to create a process_in-the-middle:
	%spawn( fun() -> init_driver( ServiceName, DriverExecPath ) end ),
	init_driver( ServiceName, DriverExecPath ),

	post_launch( ServiceName ).


% (helper)
launch_link( ServiceName, ExecPath ) ->

	% To be killed in turn should the port fail:
	process_flag( trap_exit, false ),

	% No need to create a process-in-the-middle:
	%spawn_link( fun() -> init_driver( ServiceName, DriverExecPath ) end ),
	init_driver( ServiceName, DriverExecPath ),

	post_launch( ServiceName ).


% Inits the driver of specified service.
%
% (helper)
%
init_driver( ServiceName, DriverExecPath ) ->

	% Used to intercept driver crashes, when was a spawned process:
	%process_flag( trap_exit, true ),

	% Now relying on the process dictionary:
	%trace_utils:debug_fmt( "Registering (locally) as '~s'.", [ ServiceName ] ),

	% Not using anymore an intermediate process:
	%naming_utils:register_as( _Pid=self(), _RegistrationName=ServiceName,
	%						  local_only ),

	% Will store the spawned port for later use in the process dictionary of the
	% calling user process:

	ServiceKey = get_service_key_for( ServiceName ),

	case process_dictionary:get( ServiceKey ) of

		undefined ->
			ok;

		_ ->
			trace_utils:error_fmt( "Service key '~s', for service '~s', "
								   "already registered; service already "
								   "started?",
								   [ ServiceKey, ServiceName ] ),
			throw( { service_key_already_set, ServiceKey } )

	end,

	% Respect the erl_interface conventions:
	Port = open_port( { spawn, DriverExecPath }, [ { packet, 2 }, binary ] ),

	process_dictionary:put( ServiceKey, Port ).

	% No need for a main loop, we drive the (direct) communication:
	%driver_main_loop( Port, ServiceName ).




% Main loop of the driver process:
driver_main_loop( Port, ServiceName ) ->

	trace_utils:debug_fmt( "Driver looping over, using port ~p.", [ Port ] ),

	receive

		{ call, CallerPid, Msg } ->

			Port ! { self(), { command, term_to_binary( Msg ) } } ,

			receive

				{ Port, { data, Data } } ->
					CallerPid ! { ServiceName, binary_to_term( Data ) };

				{ Port, { exit_status, Status } } when Status > 128 ->
					io:format( "Port terminated with signal: ~p~n",
							  [ Status - 128 ] ),
					exit( { port_terminated, Status } );

				{ Port, { exit_status, Status } } ->
					io:format( "Port terminated with status: ~p~n",
							  [ Status ] ),
					exit( { port_terminated, Status } );

				% Should the executable controlled by this port crash (ex:
				% SEGV), a 'normal' reason is still returned:
				%
				{ 'EXIT', Port, Reason } ->
					%io:format( "Driver: error exit triggered from port ~p "
					%		   "(~p)~n", [ Port, Reason ] ),
					% Better than {port_terminated,foobar_service,normal}:
					case Reason of

						normal ->
							% A 'normal' reason would be misleading:
							throw( { command_failed,
									 ServiceName, Msg } );
						_ ->
							throw( { command_failed,
									ServiceName, Msg,
									Reason } )

					end;

				Unexpected ->
					io:format( "Unexpected call-related message: ~p~n",
							   [ Unexpected ] ),
					throw( { unexpected_from_call,Unexpected  } )


			% Longer time-out as the crashes are expected to be detected before,
			% through EXIT messages:
			%
			after 5000 ->
				throw( { no_answer_to, Msg } )

			end,

			loop( Port );


		stop ->

			Port ! { self(), close },

			receive

				{ Port, closed } ->
					io:format( "Driver: exit on close triggered.~n" ),
					timer:sleep( 500 ),
					% Implicit name unregistering.
					exit( normal );

				{ 'EXIT', Port, _Reason=normal } ->
					%io:format( "Driver: normal exit triggered.~n" ),
					%timer:sleep( 500 ),
					exit( normal );

				{ 'EXIT', Port, Reason } ->
					io:format( "Driver : crashing exit (~p) triggered by ~p.~n",
							   [ Reason, Port ] ),
					timer:sleep( 500 ),
					throw( { crashing_exit, Port, Reason } )

			end;


		{ 'EXIT', Port, Reason } ->
			io:format( "Driver: error exit triggered: ~p~n", [ Reason ] ),
			timer:sleep( 500 ),
			throw( { port_terminated, ServiceName, Reason } );

		Unexpected ->
			io:format( "Driver: unexpected message received (ignored): ~p~n",
					   [ Unexpected ] ),
			loop( Port )

	end.



% (helper, common to launch with or without link, introduced when an
% intermediate process used to be spawned)
%
post_launch( ServiceName ) ->

	% Ex: [ {foo,1}, {bar,2}, {baz,1}, {tur,1}, {frob,1} ].
	ExportedFunIds = ServiceName:list_exported_service_functions(),

	% For some services (ex: HDF5, OpenGL support, etc.), a large number of
	% functions may have to be exported; to bet on rather constant, low look-up
	% efforts we precompute from previous list a table whose keys are the
	% function identifiers and whose corresponding values are their index
	% (starting at 1) in that list.
	%
	% Ex: the value associated to {bar,2} shall be 2.

	IndexedIds = add_indexes( ExportedFunIds, _Acc=[] ),

	IdTable = get_indexed_table( ExportedFunIds ),

	% For faster/easier access, we store this table in the process dictionary of
	% the calling process:


	% Finally ensure that at return the service is already up and running:
	wait_for( ServiceName ).



% (helper)
get_indexed_table( ExportedFunIds ) ->
	get_indexed_table( ExportedFunIds, table:new(), _Count=1 ).


% (helper)
get_indexed_table( _ExportedFunIds=[], IdTable, _Count ) ->
	IdTable;

get_indexed_table( _ExportedFunIds=[ FunId | T ], IdTable, Count ) ->

	% Check no duplicates:
	NewIdTable = table:addNewEntry( FunId, Count, IdTable ),

	get_indexed_table( T, NewIdTable, Count+1 ).



% Waits until the service is ready, otherwise the first use of it may fail,
% should it be triggered before the spawned process gets registered.
%
wait_for( DriverName )->

	log( "Waiting for registration of '~s'.~n", [ DriverName ] ),

	case erlang:whereis( DriverName ) of

		undefined ->
			timer:sleep( 100 ),
			wait_for( DriverName );

		Pid ->
			%io:format( "Driver is ~p.~n", [ Pid ] ),
			Pid

	end.


call_port_for( _FunctionName, _Arity, _Arguments ) ->
	fixme.


% Logs specified service-related message.
%
-spec log( text_utils:ustring() ) -> void().
log( Message ) ->
	trace_utils:debug( Message ).



% Logs specified service-related message.
%
-spec log( text_utils:format_string(), text_utils:format_values() ) -> void().
log( FormatString, Values ) ->
	log( text_utils:format( FormatString, Values ) ).





% Service Driver section.


% The actual bridge from the user code to the port.
%
% The identifier will suffice, no real need to pass along the
% basic_utils:function_name().
%
-spec call_port_for( service_key(), function_seaplus_driver_id(), function_params() ) ->
						   function_result().
call_port_for( ServiceKey, FunctionId, Params ) ->

	TargetPort = case process_dictionary:get( ServiceKey ) of

		undefined ->
			trace_utils:error_fmt( "Service key '~s' not set in process "
				"dictionary, has the corresponding been started?",
				[ ServiceKey ] ),
			throw( { service_key_not_set, ServiceKey } );

		V ->
			V

	end,

	% Vaguely similar to WOOPER conventions:
	Message = { FunctionId, Params },

	TargetPort ! { executeFunction, Message, self() },

	receive

		{ ?some_service_registration_name, Result } ->
			Result;

		{ 'EXIT', _seaplus_driverPid, Reason } ->
			%io:format( "Received exit failure from driver ~p, reason: ~p",
			%		   [ DriverPid, Reason ] ),
			throw( { driver_crashed, Reason } );

		Unexpected ->
			io:format( "Driver call: unexpected message received: ~p~n",
					   [ Unexpected ] ),
			throw( { unexpected_driver_message, Unexpected } )

	end.
