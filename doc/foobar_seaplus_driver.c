

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * 'foobar' service API, the Erlang parameters received from the port into
 * C variables that can be passed to the service functions, and to perform the
 * reciprocal operation on their results, so that they can be sent back to the
 * Erlang calling side.
 *
 */


// Generated by the Seaplus parse transform, based on foobar.erl:
#include "foobar_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the service:
#include "foobar.h"


// For free:
#include <stdlib.h>


int main()
{

  // Provided by the Seaplus library:
  byte * current_read_buf ;

  input_buffer read_buf = &current_read_buf ;

  start_seaplus_driver( read_buf ) ;

  // For the mandatory result:
  output_buffer output_sm_buf ;

  LOG_TRACE( "foobar driver started." ) ;

  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( read_buf ) > 0 )
  {

	LOG_TRACE( "New command received." ) ;

	// Current index in the input buffer (for decoding purpose):
	buffer_index index = 0 ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;

	read_function_information( read_buf, &index, &current_fun_id, &param_count ) ;

	LOG_DEBUG( "Function identifier is %u, arity is %u (new index is %u).",
	  current_fun_id, param_count, index ) ;

	prepare_for_command( &output_sm_buf ) ;


	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{

    case FOO_1_ID:

        LOG_DEBUG( "Executing foo/1." ) ;
        check_arity_is( 1, param_count, FOO_1_ID ) ;

        // Add an Erlang term -> C conversion here for each parameter of interest:
        // (refer to seaplus_getters.h for the conversion functions)
        // Ex (supposing int):
        // int i = read_int_parameter( read_buf, &index ) ;

        // This allows then calling the C counterpart of foo/1:
        // Ex: float f = some_service_function( i ) ;

        // Then write the returned result to the Erlang side:
        // (refer to seaplus_setters.h for the conversion functions)
        // Ex: write_double_result( &output_sm_buf, (double) f ) ;

        // Do not forget to deallocate any relevant memory!

        break ;


    case BAR_2_ID:

        LOG_DEBUG( "Executing bar/2." ) ;
        check_arity_is( 2, param_count, BAR_2_ID ) ;

        // Add an Erlang term -> C conversion here for each parameter of interest:
        // (refer to seaplus_getters.h for the conversion functions)
        // Ex (supposing int):
        // int i = read_int_parameter( read_buf, &index ) ;

        // This allows then calling the C counterpart of bar/2:
        // Ex: float f = some_service_function( i ) ;

        // Then write the returned result to the Erlang side:
        // (refer to seaplus_setters.h for the conversion functions)
        // Ex: write_double_result( &output_sm_buf, (double) f ) ;

        // Do not forget to deallocate any relevant memory!

        break ;


    case BAZ_2_ID:

        LOG_DEBUG( "Executing baz/2." ) ;
        check_arity_is( 2, param_count, BAZ_2_ID ) ;

        // Add an Erlang term -> C conversion here for each parameter of interest:
        // (refer to seaplus_getters.h for the conversion functions)
        // Ex (supposing int):
        // int i = read_int_parameter( read_buf, &index ) ;

        // This allows then calling the C counterpart of baz/2:
        // Ex: float f = some_service_function( i ) ;

        // Then write the returned result to the Erlang side:
        // (refer to seaplus_setters.h for the conversion functions)
        // Ex: write_double_result( &output_sm_buf, (double) f ) ;

        // Do not forget to deallocate any relevant memory!

        break ;


    case TUR_0_ID:

        LOG_DEBUG( "Executing tur/0." ) ;
        check_arity_is( 0, param_count, TUR_0_ID ) ;

        // Add an Erlang term -> C conversion here for each parameter of interest:
        // (refer to seaplus_getters.h for the conversion functions)
        // Ex (supposing int):
        // int i = read_int_parameter( read_buf, &index ) ;

        // This allows then calling the C counterpart of tur/0:
        // Ex: float f = some_service_function( i ) ;

        // Then write the returned result to the Erlang side:
        // (refer to seaplus_setters.h for the conversion functions)
        // Ex: write_double_result( &output_sm_buf, (double) f ) ;

        // Do not forget to deallocate any relevant memory!

        break ;


    case FROB_1_ID:

        LOG_DEBUG( "Executing frob/1." ) ;
        check_arity_is( 1, param_count, FROB_1_ID ) ;

        // Add an Erlang term -> C conversion here for each parameter of interest:
        // (refer to seaplus_getters.h for the conversion functions)
        // Ex (supposing int):
        // int i = read_int_parameter( read_buf, &index ) ;

        // This allows then calling the C counterpart of frob/1:
        // Ex: float f = some_service_function( i ) ;

        // Then write the returned result to the Erlang side:
        // (refer to seaplus_setters.h for the conversion functions)
        // Ex: write_double_result( &output_sm_buf, (double) f ) ;

        // Do not forget to deallocate any relevant memory!

        break ;


	default:
	  raise_error( "Unknown function identifier: %u", current_fun_id ) ;

	}

	finalize_command_after_writing( &output_sm_buf ) ;

  }

  // output_sm_buf internally already freed appropriately.

  stop_seaplus_driver( read_buf ) ;

}
